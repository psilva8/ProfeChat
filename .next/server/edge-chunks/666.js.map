{"version":3,"file":"edge-chunks/666.js","mappings":"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","sources":["webpack://_N_E/./node_modules/openai/internal/qs/formats.mjs","webpack://_N_E/./node_modules/openai/internal/qs/utils.mjs","webpack://_N_E/./node_modules/openai/internal/qs/stringify.mjs","webpack://_N_E/./node_modules/openai/version.mjs","webpack://_N_E/./node_modules/openai/_shims/registry.mjs","webpack://_N_E/./node_modules/openai/_shims/MultipartBody.mjs","webpack://_N_E/./node_modules/openai/_shims/web-runtime.mjs","webpack://_N_E/./node_modules/openai/_shims/index.mjs","webpack://_N_E/./node_modules/openai/error.mjs","webpack://_N_E/./node_modules/openai/internal/decoders/line.mjs","webpack://_N_E/./node_modules/openai/internal/stream-utils.mjs","webpack://_N_E/./node_modules/openai/streaming.mjs","webpack://_N_E/./node_modules/openai/uploads.mjs","webpack://_N_E/./node_modules/openai/core.mjs","webpack://_N_E/./node_modules/openai/resource.mjs","webpack://_N_E/./node_modules/openai/resources/completions.mjs","webpack://_N_E/./node_modules/openai/resources/chat/completions/messages.mjs","webpack://_N_E/./node_modules/openai/pagination.mjs","webpack://_N_E/./node_modules/openai/resources/chat/completions/completions.mjs","webpack://_N_E/./node_modules/openai/resources/chat/chat.mjs","webpack://_N_E/./node_modules/openai/resources/embeddings.mjs","webpack://_N_E/./node_modules/openai/resources/files.mjs","webpack://_N_E/./node_modules/openai/resources/images.mjs","webpack://_N_E/./node_modules/openai/resources/audio/speech.mjs","webpack://_N_E/./node_modules/openai/resources/audio/transcriptions.mjs","webpack://_N_E/./node_modules/openai/resources/audio/translations.mjs","webpack://_N_E/./node_modules/openai/resources/audio/audio.mjs","webpack://_N_E/./node_modules/openai/resources/moderations.mjs","webpack://_N_E/./node_modules/openai/resources/models.mjs","webpack://_N_E/./node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs","webpack://_N_E/./node_modules/openai/resources/fine-tuning/jobs/jobs.mjs","webpack://_N_E/./node_modules/openai/resources/fine-tuning/fine-tuning.mjs","webpack://_N_E/./node_modules/openai/lib/Util.mjs","webpack://_N_E/./node_modules/openai/resources/vector-stores/files.mjs","webpack://_N_E/./node_modules/openai/resources/vector-stores/file-batches.mjs","webpack://_N_E/./node_modules/openai/resources/vector-stores/vector-stores.mjs","webpack://_N_E/./node_modules/openai/resources/beta/assistants.mjs","webpack://_N_E/./node_modules/openai/lib/RunnableFunction.mjs","webpack://_N_E/./node_modules/openai/lib/chatCompletionUtils.mjs","webpack://_N_E/./node_modules/openai/lib/EventStream.mjs","webpack://_N_E/./node_modules/openai/lib/parser.mjs","webpack://_N_E/./node_modules/openai/lib/AbstractChatCompletionRunner.mjs","webpack://_N_E/./node_modules/openai/lib/ChatCompletionRunner.mjs","webpack://_N_E/./node_modules/openai/_vendor/partial-json-parser/parser.mjs","webpack://_N_E/./node_modules/openai/lib/ChatCompletionStream.mjs","webpack://_N_E/./node_modules/openai/lib/ChatCompletionStreamingRunner.mjs","webpack://_N_E/./node_modules/openai/resources/beta/chat/completions.mjs","webpack://_N_E/./node_modules/openai/resources/beta/chat/chat.mjs","webpack://_N_E/./node_modules/openai/resources/beta/realtime/sessions.mjs","webpack://_N_E/./node_modules/openai/resources/beta/realtime/transcription-sessions.mjs","webpack://_N_E/./node_modules/openai/resources/beta/realtime/realtime.mjs","webpack://_N_E/./node_modules/openai/lib/AssistantStream.mjs","webpack://_N_E/./node_modules/openai/resources/beta/threads/messages.mjs","webpack://_N_E/./node_modules/openai/resources/beta/threads/runs/steps.mjs","webpack://_N_E/./node_modules/openai/resources/beta/threads/runs/runs.mjs","webpack://_N_E/./node_modules/openai/resources/beta/threads/threads.mjs","webpack://_N_E/./node_modules/openai/resources/beta/beta.mjs","webpack://_N_E/./node_modules/openai/resources/batches.mjs","webpack://_N_E/./node_modules/openai/resources/uploads/parts.mjs","webpack://_N_E/./node_modules/openai/resources/uploads/uploads.mjs","webpack://_N_E/./node_modules/openai/lib/ResponsesParser.mjs","webpack://_N_E/./node_modules/openai/resources/responses/input-items.mjs","webpack://_N_E/./node_modules/openai/lib/responses/ResponseStream.mjs","webpack://_N_E/./node_modules/openai/resources/responses/responses.mjs","webpack://_N_E/./node_modules/openai/index.mjs","webpack://_N_E/<anon>"],"sourcesContent":["export const default_format = 'RFC3986';\nexport const formatters = {\n    RFC1738: (v) => String(v).replace(/%20/g, '+'),\n    RFC3986: (v) => String(v),\n};\nexport const RFC1738 = 'RFC1738';\nexport const RFC3986 = 'RFC3986';\n//# sourceMappingURL=formats.mjs.map","import { RFC1738 } from \"./formats.mjs\";\nconst has = Object.prototype.hasOwnProperty;\nconst is_array = Array.isArray;\nconst hex_table = (() => {\n    const array = [];\n    for (let i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n    return array;\n})();\nfunction compact_queue(queue) {\n    while (queue.length > 1) {\n        const item = queue.pop();\n        if (!item)\n            continue;\n        const obj = item.obj[item.prop];\n        if (is_array(obj)) {\n            const compacted = [];\n            for (let j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n            // @ts-ignore\n            item.obj[item.prop] = compacted;\n        }\n    }\n}\nfunction array_to_object(source, options) {\n    const obj = options && options.plainObjects ? Object.create(null) : {};\n    for (let i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n    return obj;\n}\nexport function merge(target, source, options = {}) {\n    if (!source) {\n        return target;\n    }\n    if (typeof source !== 'object') {\n        if (is_array(target)) {\n            target.push(source);\n        }\n        else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) ||\n                !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        }\n        else {\n            return [target, source];\n        }\n        return target;\n    }\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n    let mergeTarget = target;\n    if (is_array(target) && !is_array(source)) {\n        // @ts-ignore\n        mergeTarget = array_to_object(target, options);\n    }\n    if (is_array(target) && is_array(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                const targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n            else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n    return Object.keys(source).reduce(function (acc, key) {\n        const value = source[key];\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        }\n        else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n}\nexport function assign_single_source(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n}\nexport function decode(str, _, charset) {\n    const strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    }\n    catch (e) {\n        return strWithoutPlus;\n    }\n}\nconst limit = 1024;\nexport const encode = (str, _defaultEncoder, charset, _kind, format) => {\n    // This code was originally written by Brian White for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n    let string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    }\n    else if (typeof str !== 'string') {\n        string = String(str);\n    }\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n    let out = '';\n    for (let j = 0; j < string.length; j += limit) {\n        const segment = string.length >= limit ? string.slice(j, j + limit) : string;\n        const arr = [];\n        for (let i = 0; i < segment.length; ++i) {\n            let c = segment.charCodeAt(i);\n            if (c === 0x2d || // -\n                c === 0x2e || // .\n                c === 0x5f || // _\n                c === 0x7e || // ~\n                (c >= 0x30 && c <= 0x39) || // 0-9\n                (c >= 0x41 && c <= 0x5a) || // a-z\n                (c >= 0x61 && c <= 0x7a) || // A-Z\n                (format === RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n            if (c < 0x80) {\n                arr[arr.length] = hex_table[c];\n                continue;\n            }\n            if (c < 0x800) {\n                arr[arr.length] = hex_table[0xc0 | (c >> 6)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            if (c < 0xd800 || c >= 0xe000) {\n                arr[arr.length] =\n                    hex_table[0xe0 | (c >> 12)] + hex_table[0x80 | ((c >> 6) & 0x3f)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            i += 1;\n            c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff));\n            arr[arr.length] =\n                hex_table[0xf0 | (c >> 18)] +\n                    hex_table[0x80 | ((c >> 12) & 0x3f)] +\n                    hex_table[0x80 | ((c >> 6) & 0x3f)] +\n                    hex_table[0x80 | (c & 0x3f)];\n        }\n        out += arr.join('');\n    }\n    return out;\n};\nexport function compact(value) {\n    const queue = [{ obj: { o: value }, prop: 'o' }];\n    const refs = [];\n    for (let i = 0; i < queue.length; ++i) {\n        const item = queue[i];\n        // @ts-ignore\n        const obj = item.obj[item.prop];\n        const keys = Object.keys(obj);\n        for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n    compact_queue(queue);\n    return value;\n}\nexport function is_regexp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nexport function is_buffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n}\nexport function combine(a, b) {\n    return [].concat(a, b);\n}\nexport function maybe_map(val, fn) {\n    if (is_array(val)) {\n        const mapped = [];\n        for (let i = 0; i < val.length; i += 1) {\n            mapped.push(fn(val[i]));\n        }\n        return mapped;\n    }\n    return fn(val);\n}\n//# sourceMappingURL=utils.mjs.map","import { encode, is_buffer, maybe_map } from \"./utils.mjs\";\nimport { default_format, formatters } from \"./formats.mjs\";\nconst has = Object.prototype.hasOwnProperty;\nconst array_prefix_generators = {\n    brackets(prefix) {\n        return String(prefix) + '[]';\n    },\n    comma: 'comma',\n    indices(prefix, key) {\n        return String(prefix) + '[' + key + ']';\n    },\n    repeat(prefix) {\n        return String(prefix);\n    },\n};\nconst is_array = Array.isArray;\nconst push = Array.prototype.push;\nconst push_to_array = function (arr, value_or_array) {\n    push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);\n};\nconst to_ISO = Date.prototype.toISOString;\nconst defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: 'indices',\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: encode,\n    encodeValuesOnly: false,\n    format: default_format,\n    formatter: formatters[default_format],\n    /** @deprecated */\n    indices: false,\n    serializeDate(date) {\n        return to_ISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false,\n};\nfunction is_non_nullish_primitive(v) {\n    return (typeof v === 'string' ||\n        typeof v === 'number' ||\n        typeof v === 'boolean' ||\n        typeof v === 'symbol' ||\n        typeof v === 'bigint');\n}\nconst sentinel = {};\nfunction inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {\n    let obj = object;\n    let tmp_sc = sideChannel;\n    let step = 0;\n    let find_flag = false;\n    while ((tmp_sc = tmp_sc.get(sentinel)) !== void undefined && !find_flag) {\n        // Where object last appeared in the ref tree\n        const pos = tmp_sc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            }\n            else {\n                find_flag = true; // Break while\n            }\n        }\n        if (typeof tmp_sc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    }\n    else if (obj instanceof Date) {\n        obj = serializeDate?.(obj);\n    }\n    else if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        obj = maybe_map(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate?.(value);\n            }\n            return value;\n        });\n    }\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ?\n                // @ts-expect-error\n                encoder(prefix, defaults.encoder, charset, 'key', format)\n                : prefix;\n        }\n        obj = '';\n    }\n    if (is_non_nullish_primitive(obj) || is_buffer(obj)) {\n        if (encoder) {\n            const key_value = encodeValuesOnly ? prefix\n                // @ts-expect-error\n                : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [\n                formatter?.(key_value) +\n                    '=' +\n                    // @ts-expect-error\n                    formatter?.(encoder(obj, defaults.encoder, charset, 'value', format)),\n            ];\n        }\n        return [formatter?.(prefix) + '=' + formatter?.(String(obj))];\n    }\n    const values = [];\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n    let obj_keys;\n    if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            // @ts-expect-error values only\n            obj = maybe_map(obj, encoder);\n        }\n        obj_keys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    }\n    else if (is_array(filter)) {\n        obj_keys = filter;\n    }\n    else {\n        const keys = Object.keys(obj);\n        obj_keys = sort ? keys.sort(sort) : keys;\n    }\n    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n    const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;\n    if (allowEmptyArrays && is_array(obj) && obj.length === 0) {\n        return adjusted_prefix + '[]';\n    }\n    for (let j = 0; j < obj_keys.length; ++j) {\n        const key = obj_keys[j];\n        const value = \n        // @ts-ignore\n        typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n        if (skipNulls && value === null) {\n            continue;\n        }\n        // @ts-ignore\n        const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\\./g, '%2E') : key;\n        const key_prefix = is_array(obj) ?\n            typeof generateArrayPrefix === 'function' ?\n                generateArrayPrefix(adjusted_prefix, encoded_key)\n                : adjusted_prefix\n            : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');\n        sideChannel.set(object, step);\n        const valueSideChannel = new WeakMap();\n        valueSideChannel.set(sentinel, sideChannel);\n        push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, \n        // @ts-ignore\n        generateArrayPrefix === 'comma' && encodeValuesOnly && is_array(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));\n    }\n    return values;\n}\nfunction normalize_stringify_options(opts = defaults) {\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n    const charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    let format = default_format;\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    const formatter = formatters[format];\n    let filter = defaults.filter;\n    if (typeof opts.filter === 'function' || is_array(opts.filter)) {\n        filter = opts.filter;\n    }\n    let arrayFormat;\n    if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {\n        arrayFormat = opts.arrayFormat;\n    }\n    else if ('indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    }\n    else {\n        arrayFormat = defaults.arrayFormat;\n    }\n    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n    const allowDots = typeof opts.allowDots === 'undefined' ?\n        !!opts.encodeDotInKeys === true ?\n            true\n            : defaults.allowDots\n        : !!opts.allowDots;\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        // @ts-ignore\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        // @ts-ignore\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n    };\n}\nexport function stringify(object, opts = {}) {\n    let obj = object;\n    const options = normalize_stringify_options(opts);\n    let obj_keys;\n    let filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    }\n    else if (is_array(options.filter)) {\n        filter = options.filter;\n        obj_keys = filter;\n    }\n    const keys = [];\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n    const generateArrayPrefix = array_prefix_generators[options.arrayFormat];\n    const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n    if (!obj_keys) {\n        obj_keys = Object.keys(obj);\n    }\n    if (options.sort) {\n        obj_keys.sort(options.sort);\n    }\n    const sideChannel = new WeakMap();\n    for (let i = 0; i < obj_keys.length; ++i) {\n        const key = obj_keys[i];\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        push_to_array(keys, inner_stringify(obj[key], key, \n        // @ts-expect-error\n        generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));\n    }\n    const joined = keys.join(options.delimiter);\n    let prefix = options.addQueryPrefix === true ? '?' : '';\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        }\n        else {\n            // encodeURIComponent('')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n    return joined.length > 0 ? prefix + joined : '';\n}\n//# sourceMappingURL=stringify.mjs.map","export const VERSION = '4.89.0'; // x-release-please-version\n//# sourceMappingURL=version.mjs.map","export let auto = false;\nexport let kind = undefined;\nexport let fetch = undefined;\nexport let Request = undefined;\nexport let Response = undefined;\nexport let Headers = undefined;\nexport let FormData = undefined;\nexport let Blob = undefined;\nexport let File = undefined;\nexport let ReadableStream = undefined;\nexport let getMultipartRequestOptions = undefined;\nexport let getDefaultAgent = undefined;\nexport let fileFromPath = undefined;\nexport let isFsReadStream = undefined;\nexport function setShims(shims, options = { auto: false }) {\n    if (auto) {\n        throw new Error(`you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`);\n    }\n    if (kind) {\n        throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${kind}'\\``);\n    }\n    auto = options.auto;\n    kind = shims.kind;\n    fetch = shims.fetch;\n    Request = shims.Request;\n    Response = shims.Response;\n    Headers = shims.Headers;\n    FormData = shims.FormData;\n    Blob = shims.Blob;\n    File = shims.File;\n    ReadableStream = shims.ReadableStream;\n    getMultipartRequestOptions = shims.getMultipartRequestOptions;\n    getDefaultAgent = shims.getDefaultAgent;\n    fileFromPath = shims.fileFromPath;\n    isFsReadStream = shims.isFsReadStream;\n}\n//# sourceMappingURL=registry.mjs.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nexport class MultipartBody {\n    constructor(body) {\n        this.body = body;\n    }\n    get [Symbol.toStringTag]() {\n        return 'MultipartBody';\n    }\n}\n//# sourceMappingURL=MultipartBody.mjs.map","import { MultipartBody } from \"./MultipartBody.mjs\";\nexport function getRuntime({ manuallyImported } = {}) {\n    const recommendation = manuallyImported ?\n        `You may need to use polyfills`\n        : `Add one of these imports before your first \\`import  from 'openai'\\`:\n- \\`import 'openai/shims/node'\\` (if you're running on Node)\n- \\`import 'openai/shims/web'\\` (otherwise)\n`;\n    let _fetch, _Request, _Response, _Headers;\n    try {\n        // @ts-ignore\n        _fetch = fetch;\n        // @ts-ignore\n        _Request = Request;\n        // @ts-ignore\n        _Response = Response;\n        // @ts-ignore\n        _Headers = Headers;\n    }\n    catch (error) {\n        throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);\n    }\n    return {\n        kind: 'web',\n        fetch: _fetch,\n        Request: _Request,\n        Response: _Response,\n        Headers: _Headers,\n        FormData: \n        // @ts-ignore\n        typeof FormData !== 'undefined' ? FormData : (class FormData {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);\n            }\n        }),\n        Blob: typeof Blob !== 'undefined' ? Blob : (class Blob {\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);\n            }\n        }),\n        File: \n        // @ts-ignore\n        typeof File !== 'undefined' ? File : (class File {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);\n            }\n        }),\n        ReadableStream: \n        // @ts-ignore\n        typeof ReadableStream !== 'undefined' ? ReadableStream : (class ReadableStream {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);\n            }\n        }),\n        getMultipartRequestOptions: async (\n        // @ts-ignore\n        form, opts) => ({\n            ...opts,\n            body: new MultipartBody(form),\n        }),\n        getDefaultAgent: (url) => undefined,\n        fileFromPath: () => {\n            throw new Error('The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads');\n        },\n        isFsReadStream: (value) => false,\n    };\n}\n//# sourceMappingURL=web-runtime.mjs.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport * as shims from './registry.mjs';\nimport * as auto from 'openai/_shims/auto/runtime';\nif (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\nexport * from './registry.mjs';\n","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { castToError } from \"./core.mjs\";\nexport class OpenAIError extends Error {\n}\nexport class APIError extends OpenAIError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.request_id = headers?.['x-request-id'];\n        this.error = error;\n        const data = error;\n        this.code = data?.['code'];\n        this.param = data?.['param'];\n        this.type = data?.['type'];\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({ message, cause: castToError(errorResponse) });\n        }\n        const error = errorResponse?.['error'];\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nexport class APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n    }\n}\nexport class APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nexport class APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message ?? 'Request timed out.' });\n    }\n}\nexport class BadRequestError extends APIError {\n}\nexport class AuthenticationError extends APIError {\n}\nexport class PermissionDeniedError extends APIError {\n}\nexport class NotFoundError extends APIError {\n}\nexport class ConflictError extends APIError {\n}\nexport class UnprocessableEntityError extends APIError {\n}\nexport class RateLimitError extends APIError {\n}\nexport class InternalServerError extends APIError {\n}\nexport class LengthFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the length limit was reached`);\n    }\n}\nexport class ContentFilterFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the request was rejected by the content filter`);\n    }\n}\n//# sourceMappingURL=error.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LineDecoder_carriageReturnIndex;\nimport { OpenAIError } from \"../../error.mjs\";\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nexport class LineDecoder {\n    constructor() {\n        _LineDecoder_carriageReturnIndex.set(this, void 0);\n        this.buffer = new Uint8Array();\n        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(this.buffer.length + binaryChunk.length);\n        newData.set(this.buffer);\n        newData.set(binaryChunk, this.buffer.length);\n        this.buffer = newData;\n        const lines = [];\n        let patternIndex;\n        while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"))) != null) {\n            if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, \"f\");\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") != null &&\n                (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") + 1 || patternIndex.carriage)) {\n                lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") - 1)));\n                this.buffer = this.buffer.slice(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"));\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n                continue;\n            }\n            const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = this.decodeText(this.buffer.slice(0, endIndex));\n            lines.push(line);\n            this.buffer = this.buffer.slice(patternIndex.index);\n            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n        }\n        return lines;\n    }\n    decodeText(bytes) {\n        if (bytes == null)\n            return '';\n        if (typeof bytes === 'string')\n            return bytes;\n        // Node:\n        if (typeof Buffer !== 'undefined') {\n            if (bytes instanceof Buffer) {\n                return bytes.toString();\n            }\n            if (bytes instanceof Uint8Array) {\n                return Buffer.from(bytes).toString();\n            }\n            throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n        }\n        // Browser\n        if (typeof TextDecoder !== 'undefined') {\n            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n                this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n                return this.textDecoder.decode(bytes);\n            }\n            throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n        }\n        throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n    }\n    flush() {\n        if (!this.buffer.length) {\n            return [];\n        }\n        return this.decode('\\n');\n    }\n}\n_LineDecoder_carriageReturnIndex = new WeakMap();\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = startIndex ?? 0; i < buffer.length; i++) {\n        if (buffer[i] === newline) {\n            return { preceding: i, index: i + 1, carriage: false };\n        }\n        if (buffer[i] === carriage) {\n            return { preceding: i, index: i + 1, carriage: true };\n        }\n    }\n    return null;\n}\nexport function findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 1; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=line.mjs.map","/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result?.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n//# sourceMappingURL=stream-utils.mjs.map","import { ReadableStream } from \"./_shims/index.mjs\";\nimport { OpenAIError } from \"./error.mjs\";\nimport { findDoubleNewlineIndex, LineDecoder } from \"./internal/decoders/line.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"./internal/stream-utils.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    static fromSSEResponse(response, controller) {\n        let consumed = false;\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of _iterSSEMessages(response, controller)) {\n                    if (done)\n                        continue;\n                    if (sse.data.startsWith('[DONE]')) {\n                        done = true;\n                        continue;\n                    }\n                    if (sse.event === null || sse.event.startsWith('response.')) {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        if (data && data.error) {\n                            throw new APIError(undefined, data.error, undefined, undefined);\n                        }\n                        yield data;\n                    }\n                    else {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        // TODO: Is this where the error should be thrown?\n                        if (sse.event == 'error') {\n                            throw new APIError(undefined, data.error, data.message, undefined);\n                        }\n                        yield { event: sse.event, data: data };\n                    }\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new LineDecoder();\n            const iter = ReadableStreamToAsyncIterable(readableStream);\n            for await (const chunk of iter) {\n                for (const line of lineDecoder.decode(chunk)) {\n                    yield line;\n                }\n            }\n            for (const line of lineDecoder.flush()) {\n                yield line;\n            }\n        }\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()) {\n                    if (done)\n                        continue;\n                    if (line)\n                        yield JSON.parse(line);\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller),\n            new Stream(() => teeIterator(right), this.controller),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        const encoder = new TextEncoder();\n        return new ReadableStream({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                await iter.return?.();\n            },\n        });\n    }\n}\nexport async function* _iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        throw new OpenAIError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new LineDecoder();\n    const iter = ReadableStreamToAsyncIterable(response.body);\n    for await (const sseChunk of iterSSEChunks(iter)) {\n        for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield sse;\n        }\n    }\n    for (const line of lineDecoder.flush()) {\n        const sse = sseDecoder.decode(line);\n        if (sse)\n            yield sse;\n    }\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator) {\n        if (chunk == null) {\n            continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) {\n        yield data;\n    }\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n//# sourceMappingURL=streaming.mjs.map","import { FormData, File, getMultipartRequestOptions, isFsReadStream, } from \"./_shims/index.mjs\";\nexport { fileFromPath } from \"./_shims/index.mjs\";\nexport const isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\nexport const isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    isBlobLike(value);\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\nexport const isUploadable = (value) => {\n    return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(value, name, options) {\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if (isFileLike(value)) {\n        return value;\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n        // we need to convert the `Blob` into an array buffer because the `Blob` class\n        // that `node-fetch` defines is incompatible with the web standard which results\n        // in `new File` interpreting it as a string instead of binary data.\n        const data = isBlobLike(blob) ? [(await blob.arrayBuffer())] : [blob];\n        return new File(data, name, options);\n    }\n    const bits = await getBytes(value);\n    name || (name = getName(value) ?? 'unknown_file');\n    if (!options?.type) {\n        const type = bits[0]?.type;\n        if (typeof type === 'string') {\n            options = { ...options, type };\n        }\n    }\n    return new File(bits, name, options);\n}\nasync function getBytes(value) {\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if (isBlobLike(value)) {\n        parts.push(await value.arrayBuffer());\n    }\n    else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n    ) {\n        for await (const chunk of value) {\n            parts.push(chunk); // TODO, consider validating?\n        }\n    }\n    else {\n        throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n            ?.name}; props: ${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    const props = Object.getOwnPropertyNames(value);\n    return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\nfunction getName(value) {\n    return (getStringFromMaybeBuffer(value.name) ||\n        getStringFromMaybeBuffer(value.filename) ||\n        // For fs.ReadStream\n        getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop());\n}\nconst getStringFromMaybeBuffer = (x) => {\n    if (typeof x === 'string')\n        return x;\n    if (typeof Buffer !== 'undefined' && x instanceof Buffer)\n        return String(x);\n    return undefined;\n};\nconst isAsyncIterableIterator = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nexport const isMultipartBody = (body) => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async (opts) => {\n    if (!hasUploadableValue(opts.body))\n        return opts;\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const multipartFormRequestOptions = async (opts) => {\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const createForm = async (body) => {\n    const form = new FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n    return form;\n};\nconst hasUploadableValue = (value) => {\n    if (isUploadable(value))\n        return true;\n    if (Array.isArray(value))\n        return value.some(hasUploadableValue);\n    if (value && typeof value === 'object') {\n        for (const k in value) {\n            if (hasUploadableValue(value[k]))\n                return true;\n        }\n    }\n    return false;\n};\nconst addFormValue = async (form, key, value) => {\n    if (value === undefined)\n        return;\n    if (value == null) {\n        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    }\n    // TODO: make nested formats configurable\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        form.append(key, String(value));\n    }\n    else if (isUploadable(value)) {\n        const file = await toFile(value);\n        form.append(key, file);\n    }\n    else if (Array.isArray(value)) {\n        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n    }\n    else if (typeof value === 'object') {\n        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n    }\n    else {\n        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n    }\n};\n//# sourceMappingURL=uploads.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nimport { VERSION } from \"./version.mjs\";\nimport { Stream } from \"./streaming.mjs\";\nimport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, } from \"./error.mjs\";\nimport { kind as shimsKind, getDefaultAgent, fetch, } from \"./_shims/index.mjs\";\nimport { isBlobLike, isMultipartBody } from \"./uploads.mjs\";\nexport { maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm, } from \"./uploads.mjs\";\nasync function defaultParseResponse(props) {\n    const { response } = props;\n    if (props.options.stream) {\n        debug('response', response.status, response.url, response.headers, response.body);\n        // Note: there is an invariant here that isn't represented in the type system\n        // that if you set `stream: true` the response type must also be `Stream<T>`\n        if (props.options.__streamClass) {\n            return props.options.__streamClass.fromSSEResponse(response, props.controller);\n        }\n        return Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) {\n        return null;\n    }\n    if (props.options.__binaryResponse) {\n        return response;\n    }\n    const contentType = response.headers.get('content-type');\n    const mediaType = contentType?.split(';')[0]?.trim();\n    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n    if (isJSON) {\n        const json = await response.json();\n        debug('response', response.status, response.url, response.headers, json);\n        return _addRequestID(json, response);\n    }\n    const text = await response.text();\n    debug('response', response.status, response.url, response.headers, text);\n    // TODO handle blob, arraybuffer, other content types, etc.\n    return text;\n}\nfunction _addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('x-request-id'),\n        enumerable: false,\n    });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise extends Promise {\n    constructor(responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the X-Request-ID header which is useful for debugging requests and reporting\n     * issues to OpenAI.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('x-request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then(this.parseResponse);\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nexport class APIClient {\n    constructor({ baseURL, maxRetries = 2, timeout = 600000, // 10 minutes\n    httpAgent, fetch: overriddenFetch, }) {\n        this.baseURL = baseURL;\n        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n        this.timeout = validatePositiveInteger('timeout', timeout);\n        this.httpAgent = httpAgent;\n        this.fetch = overriddenFetch ?? fetch;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    /**\n     * Override this to add your own default headers, for example:\n     *\n     *  {\n     *    ...super.defaultHeaders(),\n     *    Authorization: 'Bearer 123',\n     *  }\n     */\n    defaultHeaders(opts) {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': this.getUserAgent(),\n            ...getPlatformHeaders(),\n            ...this.authHeaders(opts),\n        };\n    }\n    /**\n     * Override this to add your own headers validation:\n     */\n    validateHeaders(headers, customHeaders) { }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then(async (opts) => {\n            const body = opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n                : opts?.body instanceof DataView ? opts.body\n                    : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n                        : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n                            : opts?.body;\n            return { method, path, ...opts, body };\n        }));\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    calculateContentLength(body) {\n        if (typeof body === 'string') {\n            if (typeof Buffer !== 'undefined') {\n                return Buffer.byteLength(body, 'utf8').toString();\n            }\n            if (typeof TextEncoder !== 'undefined') {\n                const encoder = new TextEncoder();\n                const encoded = encoder.encode(body);\n                return encoded.length.toString();\n            }\n        }\n        else if (ArrayBuffer.isView(body)) {\n            return body.byteLength.toString();\n        }\n        return null;\n    }\n    buildRequest(options, { retryCount = 0 } = {}) {\n        options = { ...options };\n        const { method, path, query, headers: headers = {} } = options;\n        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n            options.body\n            : isMultipartBody(options.body) ? options.body.body\n                : options.body ? JSON.stringify(options.body, null, 2)\n                    : null;\n        const contentLength = this.calculateContentLength(body);\n        const url = this.buildURL(path, query);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        options.timeout = options.timeout ?? this.timeout;\n        const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n        const minAgentTimeout = options.timeout + 1000;\n        if (typeof httpAgent?.options?.timeout === 'number' &&\n            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n            // Allow any given request to bump our agent active socket timeout.\n            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n            // and without mutating agent we would need to create more of them.\n            // This tradeoff optimizes for performance.\n            httpAgent.options.timeout = minAgentTimeout;\n        }\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!options.idempotencyKey)\n                options.idempotencyKey = this.defaultIdempotencyKey();\n            headers[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n        const req = {\n            method,\n            ...(body && { body: body }),\n            headers: reqHeaders,\n            ...(httpAgent && { agent: httpAgent }),\n            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n            // not compatible with standard web types\n            signal: options.signal ?? null,\n        };\n        return { req, url, timeout: options.timeout };\n    }\n    buildHeaders({ options, headers, contentLength, retryCount, }) {\n        const reqHeaders = {};\n        if (contentLength) {\n            reqHeaders['content-length'] = contentLength;\n        }\n        const defaultHeaders = this.defaultHeaders(options);\n        applyHeadersMut(reqHeaders, defaultHeaders);\n        applyHeadersMut(reqHeaders, headers);\n        // let builtin fetch set the Content-Type for multipart bodies\n        if (isMultipartBody(options.body) && shimsKind !== 'node') {\n            delete reqHeaders['content-type'];\n        }\n        // Don't set theses headers if they were already set or removed through default headers or by the caller.\n        // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account\n        // for the removal case.\n        if (getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\n            getHeader(headers, 'x-stainless-retry-count') === undefined) {\n            reqHeaders['x-stainless-retry-count'] = String(retryCount);\n        }\n        if (getHeader(defaultHeaders, 'x-stainless-timeout') === undefined &&\n            getHeader(headers, 'x-stainless-timeout') === undefined &&\n            options.timeout) {\n            reqHeaders['x-stainless-timeout'] = String(options.timeout);\n        }\n        this.validateHeaders(reqHeaders, headers);\n        return reqHeaders;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    parseHeaders(headers) {\n        return (!headers ? {}\n            : Symbol.iterator in headers ?\n                Object.fromEntries(Array.from(headers).map((header) => [...header]))\n                : { ...headers });\n    }\n    makeStatusError(status, error, message, headers) {\n        return APIError.generate(status, error, message, headers);\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this.makeRequest(options, remainingRetries));\n    }\n    async makeRequest(optionsInput, retriesRemaining) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n        await this.prepareRequest(req, { url, options });\n        debug('request', url, options, req.headers);\n        if (options.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        if (response instanceof Error) {\n            if (options.signal?.aborted) {\n                throw new APIUserAbortError();\n            }\n            if (retriesRemaining) {\n                return this.retryRequest(options, retriesRemaining);\n            }\n            if (response.name === 'AbortError') {\n                throw new APIConnectionTimeoutError();\n            }\n            throw new APIConnectionError({ cause: response });\n        }\n        const responseHeaders = createResponseHeaders(response.headers);\n        if (!response.ok) {\n            if (retriesRemaining && this.shouldRetry(response)) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n                return this.retryRequest(options, retriesRemaining, responseHeaders);\n            }\n            const errText = await response.text().catch((e) => castToError(e).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n            throw err;\n        }\n        return { response, options, controller };\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null);\n        return new PagePromise(this, request, Page);\n    }\n    buildURL(path, query) {\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        const fetchOptions = {\n            signal: controller.signal,\n            ...options,\n        };\n        if (fetchOptions.method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = fetchOptions.method.toUpperCase();\n        }\n        return (\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        this.fetch.call(undefined, url, fetchOptions).finally(() => {\n            clearTimeout(timeout);\n        }));\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.['retry-after'];\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n}\nexport class AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageInfo() != null;\n    }\n    async getNextPage() {\n        const nextInfo = this.nextPageInfo();\n        if (!nextInfo) {\n            throw new OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        const nextOptions = { ...this.options };\n        if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n            nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n        }\n        else if ('url' in nextInfo) {\n            const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n            for (const [key, value] of params) {\n                nextInfo.url.searchParams.set(key, value);\n            }\n            nextOptions.query = undefined;\n            nextOptions.path = nextInfo.url.toString();\n        }\n        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n    constructor(client, request, Page) {\n        super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexport const createResponseHeaders = (headers) => {\n    return new Proxy(Object.fromEntries(\n    // @ts-ignore\n    headers.entries()), {\n        get(target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        },\n    });\n};\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n    method: true,\n    path: true,\n    query: true,\n    body: true,\n    headers: true,\n    maxRetries: true,\n    stream: true,\n    timeout: true,\n    httpAgent: true,\n    signal: true,\n    idempotencyKey: true,\n    __metadata: true,\n    __binaryRequest: true,\n    __binaryResponse: true,\n    __streamClass: true,\n};\nexport const isRequestOptions = (obj) => {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        !isEmptyObj(obj) &&\n        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n};\nconst getPlatformProperties = () => {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    // Check if Node.js\n    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(process.platform),\n            'X-Stainless-Arch': normalizeArch(process.arch),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\nexport const safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nexport const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new OpenAIError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new OpenAIError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nexport const castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(err);\n};\nexport const ensurePresent = (value) => {\n    if (value == null)\n        throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n    return value;\n};\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env) => {\n    if (typeof process !== 'undefined') {\n        return process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof Deno !== 'undefined') {\n        return Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\nexport const coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nexport const maybeCoerceInteger = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceInteger(value);\n};\nexport const maybeCoerceFloat = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceBoolean(value);\n};\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders, newHeaders) {\n    for (const k in newHeaders) {\n        if (!hasOwn(newHeaders, k))\n            continue;\n        const lowerKey = k.toLowerCase();\n        if (!lowerKey)\n            continue;\n        const val = newHeaders[k];\n        if (val === null) {\n            delete targetHeaders[lowerKey];\n        }\n        else if (val !== undefined) {\n            targetHeaders[lowerKey] = val;\n        }\n    }\n}\nconst SENSITIVE_HEADERS = new Set(['authorization', 'api-key']);\nexport function debug(action, ...args) {\n    if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n        const modifiedArgs = args.map((arg) => {\n            if (!arg) {\n                return arg;\n            }\n            // Check for sensitive headers in request body 'headers' object\n            if (arg['headers']) {\n                // clone so we don't mutate\n                const modifiedArg = { ...arg, headers: { ...arg['headers'] } };\n                for (const header in arg['headers']) {\n                    if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                        modifiedArg['headers'][header] = 'REDACTED';\n                    }\n                }\n                return modifiedArg;\n            }\n            let modifiedArg = null;\n            // Check for sensitive headers in headers object\n            for (const header in arg) {\n                if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                    // avoid making a copy until we need to\n                    modifiedArg ?? (modifiedArg = { ...arg });\n                    modifiedArg[header] = 'REDACTED';\n                }\n            }\n            return modifiedArg ?? arg;\n        });\n        console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);\n    }\n}\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nexport const isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\nexport const isHeadersProtocol = (headers) => {\n    return typeof headers?.get === 'function';\n};\nexport const getRequiredHeader = (headers, header) => {\n    const foundHeader = getHeader(headers, header);\n    if (foundHeader === undefined) {\n        throw new Error(`Could not find ${header} header`);\n    }\n    return foundHeader;\n};\nexport const getHeader = (headers, header) => {\n    const lowerCasedHeader = header.toLowerCase();\n    if (isHeadersProtocol(headers)) {\n        // to deal with the case where the header looks like Stainless-Event-Id\n        const intercapsHeader = header[0]?.toUpperCase() +\n            header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n            const value = headers.get(key);\n            if (value) {\n                return value;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(headers)) {\n        if (key.toLowerCase() === lowerCasedHeader) {\n            if (Array.isArray(value)) {\n                if (value.length <= 1)\n                    return value[0];\n                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n                return value[0];\n            }\n            return value;\n        }\n    }\n    return undefined;\n};\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str) => {\n    if (!str)\n        return '';\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str).toString('base64');\n    }\n    if (typeof btoa !== 'undefined') {\n        return btoa(str);\n    }\n    throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\nexport function isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\n//# sourceMappingURL=core.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport class APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\n//# sourceMappingURL=resource.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Completions extends APIResource {\n    create(body, options) {\n        return this._client.post('/completions', { body, ...options, stream: body.stream ?? false });\n    }\n}\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { ChatCompletionStoreMessagesPage } from \"./completions.mjs\";\nexport class Messages extends APIResource {\n    list(completionId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(completionId, {}, query);\n        }\n        return this._client.getAPIList(`/chat/completions/${completionId}/messages`, ChatCompletionStoreMessagesPage, { query, ...options });\n    }\n}\nexport { ChatCompletionStoreMessagesPage };\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { AbstractPage } from \"./core.mjs\";\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class Page extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.object = body.object;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    /**\n     * This page represents a response that isn't actually paginated at the API level\n     * so there will never be any next page params.\n     */\n    nextPageParams() {\n        return null;\n    }\n    nextPageInfo() {\n        return null;\n    }\n}\nexport class CursorPage extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.has_more = body.has_more || false;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        if (this.has_more === false) {\n            return false;\n        }\n        return super.hasNextPage();\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    nextPageParams() {\n        const info = this.nextPageInfo();\n        if (!info)\n            return null;\n        if ('params' in info)\n            return info.params;\n        const params = Object.fromEntries(info.url.searchParams);\n        if (!Object.keys(params).length)\n            return null;\n        return params;\n    }\n    nextPageInfo() {\n        const data = this.getPaginatedItems();\n        if (!data.length) {\n            return null;\n        }\n        const id = data[data.length - 1]?.id;\n        if (!id) {\n            return null;\n        }\n        return { params: { after: id } };\n    }\n}\n//# sourceMappingURL=pagination.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as MessagesAPI from \"./messages.mjs\";\nimport { Messages } from \"./messages.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Completions extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n    create(body, options) {\n        return this._client.post('/chat/completions', { body, ...options, stream: body.stream ?? false });\n    }\n    /**\n     * Get a stored chat completion. Only Chat Completions that have been created with\n     * the `store` parameter set to `true` will be returned.\n     */\n    retrieve(completionId, options) {\n        return this._client.get(`/chat/completions/${completionId}`, options);\n    }\n    /**\n     * Modify a stored chat completion. Only Chat Completions that have been created\n     * with the `store` parameter set to `true` can be modified. Currently, the only\n     * supported modification is to update the `metadata` field.\n     */\n    update(completionId, body, options) {\n        return this._client.post(`/chat/completions/${completionId}`, { body, ...options });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/chat/completions', ChatCompletionsPage, { query, ...options });\n    }\n    /**\n     * Delete a stored chat completion. Only Chat Completions that have been created\n     * with the `store` parameter set to `true` can be deleted.\n     */\n    del(completionId, options) {\n        return this._client.delete(`/chat/completions/${completionId}`, options);\n    }\n}\nexport class ChatCompletionsPage extends CursorPage {\n}\nexport class ChatCompletionStoreMessagesPage extends CursorPage {\n}\nCompletions.ChatCompletionsPage = ChatCompletionsPage;\nCompletions.Messages = Messages;\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as CompletionsAPI from \"./completions/completions.mjs\";\nimport { ChatCompletionsPage, Completions, } from \"./completions/completions.mjs\";\nexport class Chat extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\nChat.Completions = Completions;\nChat.ChatCompletionsPage = ChatCompletionsPage;\n//# sourceMappingURL=chat.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Embeddings extends APIResource {\n    /**\n     * Creates an embedding vector representing the input text.\n     */\n    create(body, options) {\n        return this._client.post('/embeddings', { body, ...options });\n    }\n}\n//# sourceMappingURL=embeddings.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { isRequestOptions } from \"../core.mjs\";\nimport { sleep } from \"../core.mjs\";\nimport { APIConnectionTimeoutError } from \"../error.mjs\";\nimport * as Core from \"../core.mjs\";\nimport { CursorPage } from \"../pagination.mjs\";\nexport class Files extends APIResource {\n    /**\n     * Upload a file that can be used across various endpoints. Individual files can be\n     * up to 512 MB, and the size of all files uploaded by one organization can be up\n     * to 100 GB.\n     *\n     * The Assistants API supports files up to 2 million tokens and of specific file\n     * types. See the\n     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for\n     * details.\n     *\n     * The Fine-tuning API only supports `.jsonl` files. The input also has certain\n     * required formats for fine-tuning\n     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n     * models.\n     *\n     * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also\n     * has a specific required\n     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).\n     *\n     * Please [contact us](https://help.openai.com/) if you need to increase these\n     * storage limits.\n     */\n    create(body, options) {\n        return this._client.post('/files', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Returns information about a specific file.\n     */\n    retrieve(fileId, options) {\n        return this._client.get(`/files/${fileId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/files', FileObjectsPage, { query, ...options });\n    }\n    /**\n     * Delete a file.\n     */\n    del(fileId, options) {\n        return this._client.delete(`/files/${fileId}`, options);\n    }\n    /**\n     * Returns the contents of the specified file.\n     */\n    content(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, {\n            ...options,\n            headers: { Accept: 'application/binary', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n    /**\n     * Returns the contents of the specified file.\n     *\n     * @deprecated The `.content()` method should be used instead\n     */\n    retrieveContent(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, options);\n    }\n    /**\n     * Waits for the given file to be processed, default timeout is 30 mins.\n     */\n    async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {\n        const TERMINAL_STATES = new Set(['processed', 'error', 'deleted']);\n        const start = Date.now();\n        let file = await this.retrieve(id);\n        while (!file.status || !TERMINAL_STATES.has(file.status)) {\n            await sleep(pollInterval);\n            file = await this.retrieve(id);\n            if (Date.now() - start > maxWait) {\n                throw new APIConnectionTimeoutError({\n                    message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,\n                });\n            }\n        }\n        return file;\n    }\n}\nexport class FileObjectsPage extends CursorPage {\n}\nFiles.FileObjectsPage = FileObjectsPage;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport * as Core from \"../core.mjs\";\nexport class Images extends APIResource {\n    /**\n     * Creates a variation of a given image.\n     */\n    createVariation(body, options) {\n        return this._client.post('/images/variations', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an edited or extended image given an original image and a prompt.\n     */\n    edit(body, options) {\n        return this._client.post('/images/edits', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an image given a prompt.\n     */\n    generate(body, options) {\n        return this._client.post('/images/generations', { body, ...options });\n    }\n}\n//# sourceMappingURL=images.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nexport class Speech extends APIResource {\n    /**\n     * Generates audio from the input text.\n     */\n    create(body, options) {\n        return this._client.post('/audio/speech', {\n            body,\n            ...options,\n            headers: { Accept: 'application/octet-stream', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n}\n//# sourceMappingURL=speech.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Transcriptions extends APIResource {\n    create(body, options) {\n        return this._client.post('/audio/transcriptions', Core.multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }));\n    }\n}\n//# sourceMappingURL=transcriptions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Translations extends APIResource {\n    create(body, options) {\n        return this._client.post('/audio/translations', Core.multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }));\n    }\n}\n//# sourceMappingURL=translations.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as SpeechAPI from \"./speech.mjs\";\nimport { Speech } from \"./speech.mjs\";\nimport * as TranscriptionsAPI from \"./transcriptions.mjs\";\nimport { Transcriptions, } from \"./transcriptions.mjs\";\nimport * as TranslationsAPI from \"./translations.mjs\";\nimport { Translations, } from \"./translations.mjs\";\nexport class Audio extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\n        this.translations = new TranslationsAPI.Translations(this._client);\n        this.speech = new SpeechAPI.Speech(this._client);\n    }\n}\nAudio.Transcriptions = Transcriptions;\nAudio.Translations = Translations;\nAudio.Speech = Speech;\n//# sourceMappingURL=audio.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Moderations extends APIResource {\n    /**\n     * Classifies if text and/or image inputs are potentially harmful. Learn more in\n     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).\n     */\n    create(body, options) {\n        return this._client.post('/moderations', { body, ...options });\n    }\n}\n//# sourceMappingURL=moderations.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { Page } from \"../pagination.mjs\";\nexport class Models extends APIResource {\n    /**\n     * Retrieves a model instance, providing basic information about the model such as\n     * the owner and permissioning.\n     */\n    retrieve(model, options) {\n        return this._client.get(`/models/${model}`, options);\n    }\n    /**\n     * Lists the currently available models, and provides basic information about each\n     * one such as the owner and availability.\n     */\n    list(options) {\n        return this._client.getAPIList('/models', ModelsPage, options);\n    }\n    /**\n     * Delete a fine-tuned model. You must have the Owner role in your organization to\n     * delete a model.\n     */\n    del(model, options) {\n        return this._client.delete(`/models/${model}`, options);\n    }\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class ModelsPage extends Page {\n}\nModels.ModelsPage = ModelsPage;\n//# sourceMappingURL=models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Checkpoints extends APIResource {\n    list(fineTuningJobId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });\n    }\n}\nexport class FineTuningJobCheckpointsPage extends CursorPage {\n}\nCheckpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n//# sourceMappingURL=checkpoints.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as CheckpointsAPI from \"./checkpoints.mjs\";\nimport { Checkpoints, FineTuningJobCheckpointsPage, } from \"./checkpoints.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Jobs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n    }\n    /**\n     * Creates a fine-tuning job which begins the process of creating a new model from\n     * a given dataset.\n     *\n     * Response includes details of the enqueued job including job status and the name\n     * of the fine-tuned models once complete.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     */\n    create(body, options) {\n        return this._client.post('/fine_tuning/jobs', { body, ...options });\n    }\n    /**\n     * Get info about a fine-tuning job.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     */\n    retrieve(fineTuningJobId, options) {\n        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/fine_tuning/jobs', FineTuningJobsPage, { query, ...options });\n    }\n    /**\n     * Immediately cancel a fine-tune job.\n     */\n    cancel(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);\n    }\n    listEvents(fineTuningJobId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.listEvents(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {\n            query,\n            ...options,\n        });\n    }\n}\nexport class FineTuningJobsPage extends CursorPage {\n}\nexport class FineTuningJobEventsPage extends CursorPage {\n}\nJobs.FineTuningJobsPage = FineTuningJobsPage;\nJobs.FineTuningJobEventsPage = FineTuningJobEventsPage;\nJobs.Checkpoints = Checkpoints;\nJobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n//# sourceMappingURL=jobs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as JobsAPI from \"./jobs/jobs.mjs\";\nimport { FineTuningJobEventsPage, FineTuningJobsPage, Jobs, } from \"./jobs/jobs.mjs\";\nexport class FineTuning extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.jobs = new JobsAPI.Jobs(this._client);\n    }\n}\nFineTuning.Jobs = Jobs;\nFineTuning.FineTuningJobsPage = FineTuningJobsPage;\nFineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;\n//# sourceMappingURL=fine-tuning.mjs.map","/**\n * Like `Promise.allSettled()` but throws an error if any promises are rejected.\n */\nexport const allSettledWithThrow = async (promises) => {\n    const results = await Promise.allSettled(promises);\n    const rejected = results.filter((result) => result.status === 'rejected');\n    if (rejected.length) {\n        for (const result of rejected) {\n            console.error(result.reason);\n        }\n        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);\n    }\n    // Note: TS was complaining about using `.filter().map()` here for some reason\n    const values = [];\n    for (const result of results) {\n        if (result.status === 'fulfilled') {\n            values.push(result.value);\n        }\n    }\n    return values;\n};\n//# sourceMappingURL=Util.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { sleep, isRequestOptions } from \"../../core.mjs\";\nimport { CursorPage, Page } from \"../../pagination.mjs\";\nexport class Files extends APIResource {\n    /**\n     * Create a vector store file by attaching a\n     * [File](https://platform.openai.com/docs/api-reference/files) to a\n     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file.\n     */\n    retrieve(vectorStoreId, fileId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Update attributes on a vector store file.\n     */\n    update(vectorStoreId, fileId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(vectorStoreId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(vectorStoreId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store file. This will remove the file from the vector store but\n     * the file itself will not be deleted. To delete the file, use the\n     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\n     * endpoint.\n     */\n    del(vectorStoreId, fileId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Attach a file to the given vector store and wait for it to be processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const file = await this.create(vectorStoreId, body, options);\n        return await this.poll(vectorStoreId, file.id, options);\n    }\n    /**\n     * Wait for the vector store file to finish processing.\n     *\n     * Note: this will return even if the file failed to process, you need to check\n     * file.last_error and file.status to handle these cases\n     */\n    async poll(vectorStoreId, fileId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const fileResponse = await this.retrieve(vectorStoreId, fileId, {\n                ...options,\n                headers,\n            }).withResponse();\n            const file = fileResponse.data;\n            switch (file.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                case 'failed':\n                case 'completed':\n                    return file;\n            }\n        }\n    }\n    /**\n     * Upload a file to the `files` API and then attach it to the given vector store.\n     *\n     * Note the file will be asynchronously processed (you can use the alternative\n     * polling helper method to wait for processing to complete).\n     */\n    async upload(vectorStoreId, file, options) {\n        const fileInfo = await this._client.files.create({ file: file, purpose: 'assistants' }, options);\n        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);\n    }\n    /**\n     * Add a file to a vector store and poll until processing is complete.\n     */\n    async uploadAndPoll(vectorStoreId, file, options) {\n        const fileInfo = await this.upload(vectorStoreId, file, options);\n        return await this.poll(vectorStoreId, fileInfo.id, options);\n    }\n    /**\n     * Retrieve the parsed contents of a vector store file.\n     */\n    content(vectorStoreId, fileId, options) {\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, { ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n    }\n}\nexport class VectorStoreFilesPage extends CursorPage {\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class FileContentResponsesPage extends Page {\n}\nFiles.VectorStoreFilesPage = VectorStoreFilesPage;\nFiles.FileContentResponsesPage = FileContentResponsesPage;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { sleep } from \"../../core.mjs\";\nimport { allSettledWithThrow } from \"../../lib/Util.mjs\";\nimport { VectorStoreFilesPage } from \"./files.mjs\";\nexport class FileBatches extends APIResource {\n    /**\n     * Create a vector store file batch.\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file batch.\n     */\n    retrieve(vectorStoreId, batchId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancel a vector store file batch. This attempts to cancel the processing of\n     * files in this batch as soon as possible.\n     */\n    cancel(vectorStoreId, batchId, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Create a vector store batch and poll until all files have been processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const batch = await this.create(vectorStoreId, body);\n        return await this.poll(vectorStoreId, batch.id, options);\n    }\n    listFiles(vectorStoreId, batchId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.listFiles(vectorStoreId, batchId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n    }\n    /**\n     * Wait for the given file batch to be processed.\n     *\n     * Note: this will return even if one of the files failed to process, you need to\n     * check batch.file_counts.failed_count to handle this case.\n     */\n    async poll(vectorStoreId, batchId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {\n                ...options,\n                headers,\n            }).withResponse();\n            switch (batch.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                case 'failed':\n                case 'cancelled':\n                case 'completed':\n                    return batch;\n            }\n        }\n    }\n    /**\n     * Uploads the given files concurrently and then creates a vector store file batch.\n     *\n     * The concurrency limit is configurable using the `maxConcurrency` parameter.\n     */\n    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {\n        if (files == null || files.length == 0) {\n            throw new Error(`No \\`files\\` provided to process. If you've already uploaded files you should use \\`.createAndPoll()\\` instead`);\n        }\n        const configuredConcurrency = options?.maxConcurrency ?? 5;\n        // We cap the number of workers at the number of files (so we don't start any unnecessary workers)\n        const concurrencyLimit = Math.min(configuredConcurrency, files.length);\n        const client = this._client;\n        const fileIterator = files.values();\n        const allFileIds = [...fileIds];\n        // This code is based on this design. The libraries don't accommodate our environment limits.\n        // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all\n        async function processFiles(iterator) {\n            for (let item of iterator) {\n                const fileObj = await client.files.create({ file: item, purpose: 'assistants' }, options);\n                allFileIds.push(fileObj.id);\n            }\n        }\n        // Start workers to process results\n        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);\n        // Wait for all processing to complete.\n        await allSettledWithThrow(workers);\n        return await this.createAndPoll(vectorStoreId, {\n            file_ids: allFileIds,\n        });\n    }\n}\nexport { VectorStoreFilesPage };\n//# sourceMappingURL=file-batches.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport * as FileBatchesAPI from \"./file-batches.mjs\";\nimport { FileBatches, } from \"./file-batches.mjs\";\nimport * as FilesAPI from \"./files.mjs\";\nimport { FileContentResponsesPage, Files, VectorStoreFilesPage, } from \"./files.mjs\";\nimport { CursorPage, Page } from \"../../pagination.mjs\";\nexport class VectorStores extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.files = new FilesAPI.Files(this._client);\n        this.fileBatches = new FileBatchesAPI.FileBatches(this._client);\n    }\n    /**\n     * Create a vector store.\n     */\n    create(body, options) {\n        return this._client.post('/vector_stores', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store.\n     */\n    retrieve(vectorStoreId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a vector store.\n     */\n    update(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/vector_stores', VectorStoresPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store.\n     */\n    del(vectorStoreId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Search a vector store for relevant chunks based on a query and file attributes\n     * filter.\n     */\n    search(vectorStoreId, body, options) {\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {\n            body,\n            method: 'post',\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class VectorStoresPage extends CursorPage {\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class VectorStoreSearchResponsesPage extends Page {\n}\nVectorStores.VectorStoresPage = VectorStoresPage;\nVectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;\nVectorStores.Files = Files;\nVectorStores.VectorStoreFilesPage = VectorStoreFilesPage;\nVectorStores.FileContentResponsesPage = FileContentResponsesPage;\nVectorStores.FileBatches = FileBatches;\n//# sourceMappingURL=vector-stores.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Assistants extends APIResource {\n    /**\n     * Create an assistant with a model and instructions.\n     */\n    create(body, options) {\n        return this._client.post('/assistants', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves an assistant.\n     */\n    retrieve(assistantId, options) {\n        return this._client.get(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies an assistant.\n     */\n    update(assistantId, body, options) {\n        return this._client.post(`/assistants/${assistantId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/assistants', AssistantsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete an assistant.\n     */\n    del(assistantId, options) {\n        return this._client.delete(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class AssistantsPage extends CursorPage {\n}\nAssistants.AssistantsPage = AssistantsPage;\n//# sourceMappingURL=assistants.mjs.map","export function isRunnableFunctionWithParse(fn) {\n    return typeof fn.parse === 'function';\n}\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n *\n * @deprecated - please use ParsingToolFunction instead.\n */\nexport class ParsingFunction {\n    constructor(input) {\n        this.function = input.function;\n        this.parse = input.parse;\n        this.parameters = input.parameters;\n        this.description = input.description;\n        this.name = input.name;\n    }\n}\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n */\nexport class ParsingToolFunction {\n    constructor(input) {\n        this.type = 'function';\n        this.function = input;\n    }\n}\n//# sourceMappingURL=RunnableFunction.mjs.map","export const isAssistantMessage = (message) => {\n    return message?.role === 'assistant';\n};\nexport const isFunctionMessage = (message) => {\n    return message?.role === 'function';\n};\nexport const isToolMessage = (message) => {\n    return message?.role === 'tool';\n};\nexport function isPresent(obj) {\n    return obj != null;\n}\n//# sourceMappingURL=chatCompletionUtils.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nexport class EventStream {\n    constructor() {\n        _EventStream_instances.add(this);\n        this.controller = new AbortController();\n        _EventStream_connectedPromise.set(this, void 0);\n        _EventStream_resolveConnectedPromise.set(this, () => { });\n        _EventStream_rejectConnectedPromise.set(this, () => { });\n        _EventStream_endPromise.set(this, void 0);\n        _EventStream_resolveEndPromise.set(this, () => { });\n        _EventStream_rejectEndPromise.set(this, () => { });\n        _EventStream_listeners.set(this, {});\n        _EventStream_ended.set(this, false);\n        _EventStream_errored.set(this, false);\n        _EventStream_aborted.set(this, false);\n        _EventStream_catchingPromiseCreated.set(this, false);\n        __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _EventStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _EventStream_endPromise, \"f\").catch(() => { });\n    }\n    _run(executor) {\n        // Unfortunately if we call `executor()` immediately we get runtime errors about\n        // references to `this` before the `super()` constructor call returns.\n        setTimeout(() => {\n            executor().then(() => {\n                this._emitFinal();\n                this._emit('end');\n            }, __classPrivateFieldGet(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n        }, 0);\n    }\n    _connected() {\n        if (this.ended)\n            return;\n        __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _EventStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _EventStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _EventStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _EventStream_endPromise, \"f\");\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any events after end\n        if (__classPrivateFieldGet(this, _EventStream_ended, \"f\")) {\n            return;\n        }\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _EventStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _EventStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.finalChatCompletion()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() { }\n}\n_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n    __classPrivateFieldSet(this, _EventStream_errored, true, \"f\");\n    if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _EventStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n    }\n    if (error instanceof OpenAIError) {\n        return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n        const openAIError = new OpenAIError(error.message);\n        // @ts-ignore\n        openAIError.cause = error;\n        return this._emit('error', openAIError);\n    }\n    return this._emit('error', new OpenAIError(String(error)));\n};\n//# sourceMappingURL=EventStream.mjs.map","import { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from \"../error.mjs\";\nexport function makeParseableResponseFormat(response_format, parser) {\n    const obj = { ...response_format };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-response-format',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function makeParseableTextFormat(response_format, parser) {\n    const obj = { ...response_format };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-response-format',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableResponseFormat(response_format) {\n    return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\nexport function makeParseableTool(tool, { parser, callback, }) {\n    const obj = { ...tool };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-tool',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n        $callback: {\n            value: callback,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableTool(tool) {\n    return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexport function maybeParseChatCompletion(completion, params) {\n    if (!params || !hasAutoParseableInput(params)) {\n        return {\n            ...completion,\n            choices: completion.choices.map((choice) => ({\n                ...choice,\n                message: {\n                    ...choice.message,\n                    parsed: null,\n                    ...(choice.message.tool_calls ?\n                        {\n                            tool_calls: choice.message.tool_calls,\n                        }\n                        : undefined),\n                },\n            })),\n        };\n    }\n    return parseChatCompletion(completion, params);\n}\nexport function parseChatCompletion(completion, params) {\n    const choices = completion.choices.map((choice) => {\n        if (choice.finish_reason === 'length') {\n            throw new LengthFinishReasonError();\n        }\n        if (choice.finish_reason === 'content_filter') {\n            throw new ContentFilterFinishReasonError();\n        }\n        return {\n            ...choice,\n            message: {\n                ...choice.message,\n                ...(choice.message.tool_calls ?\n                    {\n                        tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? undefined,\n                    }\n                    : undefined),\n                parsed: choice.message.content && !choice.message.refusal ?\n                    parseResponseFormat(params, choice.message.content)\n                    : null,\n            },\n        };\n    });\n    return { ...completion, choices };\n}\nfunction parseResponseFormat(params, content) {\n    if (params.response_format?.type !== 'json_schema') {\n        return null;\n    }\n    if (params.response_format?.type === 'json_schema') {\n        if ('$parseRaw' in params.response_format) {\n            const response_format = params.response_format;\n            return response_format.$parseRaw(content);\n        }\n        return JSON.parse(content);\n    }\n    return null;\n}\nfunction parseToolCall(params, toolCall) {\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return {\n        ...toolCall,\n        function: {\n            ...toolCall.function,\n            parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\n                : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\n                    : null,\n        },\n    };\n}\nexport function shouldParseToolCall(params, toolCall) {\n    if (!params) {\n        return false;\n    }\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\nexport function hasAutoParseableInput(params) {\n    if (isAutoParsableResponseFormat(params.response_format)) {\n        return true;\n    }\n    return (params.tools?.some((t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true)) ?? false);\n}\nexport function validateInputTools(tools) {\n    for (const tool of tools ?? []) {\n        if (tool.type !== 'function') {\n            throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        }\n        if (tool.function.strict !== true) {\n            throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n        }\n    }\n}\n//# sourceMappingURL=parser.mjs.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\nimport { OpenAIError } from \"../error.mjs\";\nimport { isRunnableFunctionWithParse, } from \"./RunnableFunction.mjs\";\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from \"./chatCompletionUtils.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nimport { isAutoParsableTool, parseChatCompletion } from \"../lib/parser.mjs\";\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport class AbstractChatCompletionRunner extends EventStream {\n    constructor() {\n        super(...arguments);\n        _AbstractChatCompletionRunner_instances.add(this);\n        this._chatCompletions = [];\n        this.messages = [];\n    }\n    _addChatCompletion(chatCompletion) {\n        this._chatCompletions.push(chatCompletion);\n        this._emit('chatCompletion', chatCompletion);\n        const message = chatCompletion.choices[0]?.message;\n        if (message)\n            this._addMessage(message);\n        return chatCompletion;\n    }\n    _addMessage(message, emit = true) {\n        if (!('content' in message))\n            message.content = null;\n        this.messages.push(message);\n        if (emit) {\n            this._emit('message', message);\n            if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n                // Note, this assumes that {role: 'tool', content: } is always the result of a call of tool of type=function.\n                this._emit('functionCallResult', message.content);\n            }\n            else if (isAssistantMessage(message) && message.function_call) {\n                this._emit('functionCall', message.function_call);\n            }\n            else if (isAssistantMessage(message) && message.tool_calls) {\n                for (const tool_call of message.tool_calls) {\n                    if (tool_call.type === 'function') {\n                        this._emit('functionCall', tool_call.function);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @returns a promise that resolves with the final ChatCompletion, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n     */\n    async finalChatCompletion() {\n        await this.done();\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (!completion)\n            throw new OpenAIError('stream ended without producing a ChatCompletion');\n        return completion;\n    }\n    /**\n     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalContent() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalFunctionCall() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n    }\n    async finalFunctionCallResult() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n    }\n    async totalUsage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n    }\n    allChatCompletions() {\n        return [...this._chatCompletions];\n    }\n    _emitFinal() {\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (completion)\n            this._emit('finalChatCompletion', completion);\n        const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n        if (finalMessage)\n            this._emit('finalMessage', finalMessage);\n        const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n        if (finalContent)\n            this._emit('finalContent', finalContent);\n        const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n        if (finalFunctionCall)\n            this._emit('finalFunctionCall', finalFunctionCall);\n        const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n        if (finalFunctionCallResult != null)\n            this._emit('finalFunctionCallResult', finalFunctionCallResult);\n        if (this._chatCompletions.some((c) => c.usage)) {\n            this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n        }\n    }\n    async _createChatCompletion(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n        const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });\n        this._connected();\n        return this._addChatCompletion(parseChatCompletion(chatCompletion, params));\n    }\n    async _runChatCompletion(client, params, options) {\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        return await this._createChatCompletion(client, params, options);\n    }\n    async _runFunctions(client, params, options) {\n        const role = 'function';\n        const { function_call = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        const functionsByName = {};\n        for (const f of params.functions) {\n            functionsByName[f.name || f.function.name] = f;\n        }\n        const functions = params.functions.map((f) => ({\n            name: f.name || f.function.name,\n            parameters: f.parameters,\n            description: f.description,\n        }));\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                function_call,\n                functions,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.function_call)\n                return;\n            const { name, arguments: args } = message.function_call;\n            const fn = functionsByName[name];\n            if (!fn) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n                    .map((f) => JSON.stringify(f.name))\n                    .join(', ')}. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            let parsed;\n            try {\n                parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n            }\n            catch (error) {\n                this._addMessage({\n                    role,\n                    name,\n                    content: error instanceof Error ? error.message : String(error),\n                });\n                continue;\n            }\n            // @ts-expect-error it can't rule out `never` type.\n            const rawContent = await fn.function(parsed, this);\n            const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n            this._addMessage({ role, name, content });\n            if (singleFunctionToCall)\n                return;\n        }\n    }\n    async _runTools(client, params, options) {\n        const role = 'tool';\n        const { tool_choice = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        // TODO(someday): clean this logic up\n        const inputTools = params.tools.map((tool) => {\n            if (isAutoParsableTool(tool)) {\n                if (!tool.$callback) {\n                    throw new OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n                }\n                return {\n                    type: 'function',\n                    function: {\n                        function: tool.$callback,\n                        name: tool.function.name,\n                        description: tool.function.description || '',\n                        parameters: tool.function.parameters,\n                        parse: tool.$parseRaw,\n                        strict: true,\n                    },\n                };\n            }\n            return tool;\n        });\n        const functionsByName = {};\n        for (const f of inputTools) {\n            if (f.type === 'function') {\n                functionsByName[f.function.name || f.function.function.name] = f.function;\n            }\n        }\n        const tools = 'tools' in params ?\n            inputTools.map((t) => t.type === 'function' ?\n                {\n                    type: 'function',\n                    function: {\n                        name: t.function.name || t.function.function.name,\n                        parameters: t.function.parameters,\n                        description: t.function.description,\n                        strict: t.function.strict,\n                    },\n                }\n                : t)\n            : undefined;\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                tool_choice,\n                tools,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.tool_calls?.length) {\n                return;\n            }\n            for (const tool_call of message.tool_calls) {\n                if (tool_call.type !== 'function')\n                    continue;\n                const tool_call_id = tool_call.id;\n                const { name, arguments: args } = tool_call.function;\n                const fn = functionsByName[name];\n                if (!fn) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName)\n                        .map((name) => JSON.stringify(name))\n                        .join(', ')}. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                let parsed;\n                try {\n                    parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n                }\n                catch (error) {\n                    const content = error instanceof Error ? error.message : String(error);\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                // @ts-expect-error it can't rule out `never` type.\n                const rawContent = await fn.function(parsed, this);\n                const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n                this._addMessage({ role, tool_call_id, content });\n                if (singleFunctionToCall) {\n                    return;\n                }\n            }\n        }\n        return;\n    }\n}\n_AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n    let i = this.messages.length;\n    while (i-- > 0) {\n        const message = this.messages[i];\n        if (isAssistantMessage(message)) {\n            const { function_call, ...rest } = message;\n            // TODO: support audio here\n            const ret = {\n                ...rest,\n                content: message.content ?? null,\n                refusal: message.refusal ?? null,\n            };\n            if (function_call) {\n                ret.function_call = function_call;\n            }\n            return ret;\n        }\n    }\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if (isAssistantMessage(message) && message?.function_call) {\n            return message.function_call;\n        }\n        if (isAssistantMessage(message) && message?.tool_calls?.length) {\n            return message.tool_calls.at(-1)?.function;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if (isFunctionMessage(message) && message.content != null) {\n            return message.content;\n        }\n        if (isToolMessage(message) &&\n            message.content != null &&\n            typeof message.content === 'string' &&\n            this.messages.some((x) => x.role === 'assistant' &&\n                x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id))) {\n            return message.content;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n    const total = {\n        completion_tokens: 0,\n        prompt_tokens: 0,\n        total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n        if (usage) {\n            total.completion_tokens += usage.completion_tokens;\n            total.prompt_tokens += usage.prompt_tokens;\n            total.total_tokens += usage.total_tokens;\n        }\n    }\n    return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n    if (params.n != null && params.n > 1) {\n        throw new OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n    }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n    return (typeof rawContent === 'string' ? rawContent\n        : rawContent === undefined ? 'undefined'\n            : JSON.stringify(rawContent));\n};\n//# sourceMappingURL=AbstractChatCompletionRunner.mjs.map","import { AbstractChatCompletionRunner, } from \"./AbstractChatCompletionRunner.mjs\";\nimport { isAssistantMessage } from \"./chatCompletionUtils.mjs\";\nexport class ChatCompletionRunner extends AbstractChatCompletionRunner {\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n    _addMessage(message, emit = true) {\n        super._addMessage(message, emit);\n        if (isAssistantMessage(message) && message.content) {\n            this._emit('content', message.content);\n        }\n    }\n}\n//# sourceMappingURL=ChatCompletionRunner.mjs.map","const STR = 0b000000001;\nconst NUM = 0b000000010;\nconst ARR = 0b000000100;\nconst OBJ = 0b000001000;\nconst NULL = 0b000010000;\nconst BOOL = 0b000100000;\nconst NAN = 0b001000000;\nconst INFINITY = 0b010000000;\nconst MINUS_INFINITY = 0b100000000;\nconst INF = INFINITY | MINUS_INFINITY;\nconst SPECIAL = NULL | BOOL | INF | NAN;\nconst ATOM = STR | NUM | SPECIAL;\nconst COLLECTION = ARR | OBJ;\nconst ALL = ATOM | COLLECTION;\nconst Allow = {\n    STR,\n    NUM,\n    ARR,\n    OBJ,\n    NULL,\n    BOOL,\n    NAN,\n    INFINITY,\n    MINUS_INFINITY,\n    INF,\n    SPECIAL,\n    ATOM,\n    COLLECTION,\n    ALL,\n};\n// The JSON string segment was unable to be parsed completely\nclass PartialJSON extends Error {\n}\nclass MalformedJSON extends Error {\n}\n/**\n * Parse incomplete JSON\n * @param {string} jsonString Partial JSON to be parsed\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n * @returns The parsed JSON\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n * @throws {MalformedJSON} If the JSON is malformed\n */\nfunction parseJSON(jsonString, allowPartial = Allow.ALL) {\n    if (typeof jsonString !== 'string') {\n        throw new TypeError(`expecting str, got ${typeof jsonString}`);\n    }\n    if (!jsonString.trim()) {\n        throw new Error(`${jsonString} is empty`);\n    }\n    return _parseJSON(jsonString.trim(), allowPartial);\n}\nconst _parseJSON = (jsonString, allow) => {\n    const length = jsonString.length;\n    let index = 0;\n    const markPartialJSON = (msg) => {\n        throw new PartialJSON(`${msg} at position ${index}`);\n    };\n    const throwMalformedError = (msg) => {\n        throw new MalformedJSON(`${msg} at position ${index}`);\n    };\n    const parseAny = () => {\n        skipBlank();\n        if (index >= length)\n            markPartialJSON('Unexpected end of input');\n        if (jsonString[index] === '\"')\n            return parseStr();\n        if (jsonString[index] === '{')\n            return parseObj();\n        if (jsonString[index] === '[')\n            return parseArr();\n        if (jsonString.substring(index, index + 4) === 'null' ||\n            (Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return null;\n        }\n        if (jsonString.substring(index, index + 4) === 'true' ||\n            (Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return true;\n        }\n        if (jsonString.substring(index, index + 5) === 'false' ||\n            (Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index)))) {\n            index += 5;\n            return false;\n        }\n        if (jsonString.substring(index, index + 8) === 'Infinity' ||\n            (Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 8;\n            return Infinity;\n        }\n        if (jsonString.substring(index, index + 9) === '-Infinity' ||\n            (Allow.MINUS_INFINITY & allow &&\n                1 < length - index &&\n                length - index < 9 &&\n                '-Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 9;\n            return -Infinity;\n        }\n        if (jsonString.substring(index, index + 3) === 'NaN' ||\n            (Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index)))) {\n            index += 3;\n            return NaN;\n        }\n        return parseNum();\n    };\n    const parseStr = () => {\n        const start = index;\n        let escape = false;\n        index++; // skip initial quote\n        while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === '\\\\'))) {\n            escape = jsonString[index] === '\\\\' ? !escape : false;\n            index++;\n        }\n        if (jsonString.charAt(index) == '\"') {\n            try {\n                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n        else if (Allow.STR & allow) {\n            try {\n                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n            }\n            catch (e) {\n                // SyntaxError: Invalid escape sequence\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n            }\n        }\n        markPartialJSON('Unterminated string literal');\n    };\n    const parseObj = () => {\n        index++; // skip initial brace\n        skipBlank();\n        const obj = {};\n        try {\n            while (jsonString[index] !== '}') {\n                skipBlank();\n                if (index >= length && Allow.OBJ & allow)\n                    return obj;\n                const key = parseStr();\n                skipBlank();\n                index++; // skip colon\n                try {\n                    const value = parseAny();\n                    Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });\n                }\n                catch (e) {\n                    if (Allow.OBJ & allow)\n                        return obj;\n                    else\n                        throw e;\n                }\n                skipBlank();\n                if (jsonString[index] === ',')\n                    index++; // skip comma\n            }\n        }\n        catch (e) {\n            if (Allow.OBJ & allow)\n                return obj;\n            else\n                markPartialJSON(\"Expected '}' at end of object\");\n        }\n        index++; // skip final brace\n        return obj;\n    };\n    const parseArr = () => {\n        index++; // skip initial bracket\n        const arr = [];\n        try {\n            while (jsonString[index] !== ']') {\n                arr.push(parseAny());\n                skipBlank();\n                if (jsonString[index] === ',') {\n                    index++; // skip comma\n                }\n            }\n        }\n        catch (e) {\n            if (Allow.ARR & allow) {\n                return arr;\n            }\n            markPartialJSON(\"Expected ']' at end of array\");\n        }\n        index++; // skip final bracket\n        return arr;\n    };\n    const parseNum = () => {\n        if (index === 0) {\n            if (jsonString === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString);\n            }\n            catch (e) {\n                if (Allow.NUM & allow) {\n                    try {\n                        if ('.' === jsonString[jsonString.length - 1])\n                            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\n                        return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\n                    }\n                    catch (e) { }\n                }\n                throwMalformedError(String(e));\n            }\n        }\n        const start = index;\n        if (jsonString[index] === '-')\n            index++;\n        while (jsonString[index] && !',]}'.includes(jsonString[index]))\n            index++;\n        if (index == length && !(Allow.NUM & allow))\n            markPartialJSON('Unterminated number literal');\n        try {\n            return JSON.parse(jsonString.substring(start, index));\n        }\n        catch (e) {\n            if (jsonString.substring(start, index) === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n    };\n    const skipBlank = () => {\n        while (index < length && ' \\n\\r\\t'.includes(jsonString[index])) {\n            index++;\n        }\n    };\n    return parseAny();\n};\n// using this function with malformed JSON is undefined behavior\nconst partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);\nexport { partialParse, PartialJSON, MalformedJSON };\n//# sourceMappingURL=parser.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;\nimport { OpenAIError, APIUserAbortError, LengthFinishReasonError, ContentFilterFinishReasonError, } from \"../error.mjs\";\nimport { AbstractChatCompletionRunner, } from \"./AbstractChatCompletionRunner.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { hasAutoParseableInput, isAutoParsableResponseFormat, isAutoParsableTool, maybeParseChatCompletion, shouldParseToolCall, } from \"../lib/parser.mjs\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nexport class ChatCompletionStream extends AbstractChatCompletionRunner {\n    constructor(params) {\n        super();\n        _ChatCompletionStream_instances.add(this);\n        _ChatCompletionStream_params.set(this, void 0);\n        _ChatCompletionStream_choiceEventStates.set(this, void 0);\n        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n        __classPrivateFieldSet(this, _ChatCompletionStream_params, params, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n    }\n    get currentChatCompletionSnapshot() {\n        return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStream(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createChatCompletion(client, params, options) {\n        const runner = new ChatCompletionStream(params);\n        runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    async _createChatCompletion(client, params, options) {\n        super._createChatCompletion;\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const chunk of stream) {\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        this._connected();\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        let chatId;\n        for await (const chunk of stream) {\n            if (chatId && chatId !== chunk.id) {\n                // A new request has been made.\n                this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n            }\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n            chatId = chunk.id;\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n        let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n        if (state) {\n            return state;\n        }\n        state = {\n            content_done: false,\n            refusal_done: false,\n            logprobs_content_done: false,\n            logprobs_refusal_done: false,\n            done_tool_calls: new Set(),\n            current_tool_call_index: null,\n        };\n        __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n        return state;\n    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n        if (this.ended)\n            return;\n        const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n        this._emit('chunk', chunk, completion);\n        for (const choice of chunk.choices) {\n            const choiceSnapshot = completion.choices[choice.index];\n            if (choice.delta.content != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.content) {\n                this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n                this._emit('content.delta', {\n                    delta: choice.delta.content,\n                    snapshot: choiceSnapshot.message.content,\n                    parsed: choiceSnapshot.message.parsed,\n                });\n            }\n            if (choice.delta.refusal != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.refusal) {\n                this._emit('refusal.delta', {\n                    delta: choice.delta.refusal,\n                    snapshot: choiceSnapshot.message.refusal,\n                });\n            }\n            if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.content.delta', {\n                    content: choice.logprobs?.content,\n                    snapshot: choiceSnapshot.logprobs?.content ?? [],\n                });\n            }\n            if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.refusal.delta', {\n                    refusal: choice.logprobs?.refusal,\n                    snapshot: choiceSnapshot.logprobs?.refusal ?? [],\n                });\n            }\n            const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n            if (choiceSnapshot.finish_reason) {\n                __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                if (state.current_tool_call_index != null) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                }\n            }\n            for (const toolCall of choice.delta.tool_calls ?? []) {\n                if (state.current_tool_call_index !== toolCall.index) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                    // new tool call started, the previous one is done\n                    if (state.current_tool_call_index != null) {\n                        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                    }\n                }\n                state.current_tool_call_index = toolCall.index;\n            }\n            for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n                const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n                if (!toolCallSnapshot?.type) {\n                    continue;\n                }\n                if (toolCallSnapshot?.type === 'function') {\n                    this._emit('tool_calls.function.arguments.delta', {\n                        name: toolCallSnapshot.function?.name,\n                        index: toolCallDelta.index,\n                        arguments: toolCallSnapshot.function.arguments,\n                        parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n                        arguments_delta: toolCallDelta.function?.arguments ?? '',\n                    });\n                }\n                else {\n                    assertNever(toolCallSnapshot?.type);\n                }\n            }\n        }\n    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (state.done_tool_calls.has(toolCallIndex)) {\n            // we've already fired the done event\n            return;\n        }\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n        if (!toolCallSnapshot) {\n            throw new Error('no tool call snapshot');\n        }\n        if (!toolCallSnapshot.type) {\n            throw new Error('tool call snapshot missing `type`');\n        }\n        if (toolCallSnapshot.type === 'function') {\n            const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.tools?.find((tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);\n            this._emit('tool_calls.function.arguments.done', {\n                name: toolCallSnapshot.function.name,\n                index: toolCallIndex,\n                arguments: toolCallSnapshot.function.arguments,\n                parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\n                    : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\n                        : null,\n            });\n        }\n        else {\n            assertNever(toolCallSnapshot.type);\n        }\n    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (choiceSnapshot.message.content && !state.content_done) {\n            state.content_done = true;\n            const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n            this._emit('content.done', {\n                content: choiceSnapshot.message.content,\n                parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null,\n            });\n        }\n        if (choiceSnapshot.message.refusal && !state.refusal_done) {\n            state.refusal_done = true;\n            this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\n        }\n        if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n            state.logprobs_content_done = true;\n            this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\n        }\n        if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n            state.logprobs_refusal_done = true;\n            this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\n        }\n    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n        if (this.ended) {\n            throw new OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        if (!snapshot) {\n            throw new OpenAIError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n        return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"));\n    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n        const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.response_format;\n        if (isAutoParsableResponseFormat(responseFormat)) {\n            return responseFormat;\n        }\n        return null;\n    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n        var _a, _b, _c, _d;\n        let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        const { choices, ...rest } = chunk;\n        if (!snapshot) {\n            snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n                ...rest,\n                choices: [],\n            }, \"f\");\n        }\n        else {\n            Object.assign(snapshot, rest);\n        }\n        for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n            let choice = snapshot.choices[index];\n            if (!choice) {\n                choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n            }\n            if (logprobs) {\n                if (!choice.logprobs) {\n                    choice.logprobs = Object.assign({}, logprobs);\n                }\n                else {\n                    const { content, refusal, ...rest } = logprobs;\n                    assertIsEmpty(rest);\n                    Object.assign(choice.logprobs, rest);\n                    if (content) {\n                        (_a = choice.logprobs).content ?? (_a.content = []);\n                        choice.logprobs.content.push(...content);\n                    }\n                    if (refusal) {\n                        (_b = choice.logprobs).refusal ?? (_b.refusal = []);\n                        choice.logprobs.refusal.push(...refusal);\n                    }\n                }\n            }\n            if (finish_reason) {\n                choice.finish_reason = finish_reason;\n                if (__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"))) {\n                    if (finish_reason === 'length') {\n                        throw new LengthFinishReasonError();\n                    }\n                    if (finish_reason === 'content_filter') {\n                        throw new ContentFilterFinishReasonError();\n                    }\n                }\n            }\n            Object.assign(choice, other);\n            if (!delta)\n                continue; // Shouldn't happen; just in case.\n            const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\n            assertIsEmpty(rest);\n            Object.assign(choice.message, rest);\n            if (refusal) {\n                choice.message.refusal = (choice.message.refusal || '') + refusal;\n            }\n            if (role)\n                choice.message.role = role;\n            if (function_call) {\n                if (!choice.message.function_call) {\n                    choice.message.function_call = function_call;\n                }\n                else {\n                    if (function_call.name)\n                        choice.message.function_call.name = function_call.name;\n                    if (function_call.arguments) {\n                        (_c = choice.message.function_call).arguments ?? (_c.arguments = '');\n                        choice.message.function_call.arguments += function_call.arguments;\n                    }\n                }\n            }\n            if (content) {\n                choice.message.content = (choice.message.content || '') + content;\n                if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {\n                    choice.message.parsed = partialParse(choice.message.content);\n                }\n            }\n            if (tool_calls) {\n                if (!choice.message.tool_calls)\n                    choice.message.tool_calls = [];\n                for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n                    const tool_call = ((_d = choice.message.tool_calls)[index] ?? (_d[index] = {}));\n                    Object.assign(tool_call, rest);\n                    if (id)\n                        tool_call.id = id;\n                    if (type)\n                        tool_call.type = type;\n                    if (fn)\n                        tool_call.function ?? (tool_call.function = { name: fn.name ?? '', arguments: '' });\n                    if (fn?.name)\n                        tool_call.function.name = fn.name;\n                    if (fn?.arguments) {\n                        tool_call.function.arguments += fn.arguments;\n                        if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"), tool_call)) {\n                            tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);\n                        }\n                    }\n                }\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('chunk', (chunk) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(chunk);\n            }\n            else {\n                pushQueue.push(chunk);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\nfunction finalizeChatCompletion(snapshot, params) {\n    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n    const completion = {\n        ...rest,\n        id,\n        choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {\n            if (!finish_reason) {\n                throw new OpenAIError(`missing finish_reason for choice ${index}`);\n            }\n            const { content = null, function_call, tool_calls, ...messageRest } = message;\n            const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n            if (!role) {\n                throw new OpenAIError(`missing role for choice ${index}`);\n            }\n            if (function_call) {\n                const { arguments: args, name } = function_call;\n                if (args == null) {\n                    throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n                }\n                if (!name) {\n                    throw new OpenAIError(`missing function_call.name for choice ${index}`);\n                }\n                return {\n                    ...choiceRest,\n                    message: {\n                        content,\n                        function_call: { arguments: args, name },\n                        role,\n                        refusal: message.refusal ?? null,\n                    },\n                    finish_reason,\n                    index,\n                    logprobs,\n                };\n            }\n            if (tool_calls) {\n                return {\n                    ...choiceRest,\n                    index,\n                    finish_reason,\n                    logprobs,\n                    message: {\n                        ...messageRest,\n                        role,\n                        content,\n                        refusal: message.refusal ?? null,\n                        tool_calls: tool_calls.map((tool_call, i) => {\n                            const { function: fn, type, id, ...toolRest } = tool_call;\n                            const { arguments: args, name, ...fnRest } = fn || {};\n                            if (id == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                            }\n                            if (type == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                            }\n                            if (name == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n                            }\n                            if (args == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n                            }\n                            return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n                        }),\n                    },\n                };\n            }\n            return {\n                ...choiceRest,\n                message: { ...messageRest, content, role, refusal: message.refusal ?? null },\n                finish_reason,\n                index,\n                logprobs,\n            };\n        }),\n        created,\n        model,\n        object: 'chat.completion',\n        ...(system_fingerprint ? { system_fingerprint } : {}),\n    };\n    return maybeParseChatCompletion(completion, params);\n}\nfunction str(x) {\n    return JSON.stringify(x);\n}\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */\nfunction assertIsEmpty(obj) {\n    return;\n}\nfunction assertNever(_x) { }\n//# sourceMappingURL=ChatCompletionStream.mjs.map","import { ChatCompletionStream } from \"./ChatCompletionStream.mjs\";\nexport class ChatCompletionStreamingRunner extends ChatCompletionStream {\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(\n        // @ts-expect-error TODO these types are incompatible\n        params);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n}\n//# sourceMappingURL=ChatCompletionStreamingRunner.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { ChatCompletionRunner } from \"../../../lib/ChatCompletionRunner.mjs\";\nimport { ChatCompletionStreamingRunner, } from \"../../../lib/ChatCompletionStreamingRunner.mjs\";\nimport { ChatCompletionStream } from \"../../../lib/ChatCompletionStream.mjs\";\nimport { parseChatCompletion, validateInputTools } from \"../../../lib/parser.mjs\";\nexport { ChatCompletionStreamingRunner, } from \"../../../lib/ChatCompletionStreamingRunner.mjs\";\nexport { ParsingFunction, ParsingToolFunction, } from \"../../../lib/RunnableFunction.mjs\";\nexport { ChatCompletionStream } from \"../../../lib/ChatCompletionStream.mjs\";\nexport { ChatCompletionRunner, } from \"../../../lib/ChatCompletionRunner.mjs\";\nexport class Completions extends APIResource {\n    parse(body, options) {\n        validateInputTools(body.tools);\n        return this._client.chat.completions\n            .create(body, {\n            ...options,\n            headers: {\n                ...options?.headers,\n                'X-Stainless-Helper-Method': 'beta.chat.completions.parse',\n            },\n        })\n            ._thenUnwrap((completion) => parseChatCompletion(completion, body));\n    }\n    runFunctions(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);\n        }\n        return ChatCompletionRunner.runFunctions(this._client, body, options);\n    }\n    runTools(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner.runTools(this._client, body, options);\n        }\n        return ChatCompletionRunner.runTools(this._client, body, options);\n    }\n    /**\n     * Creates a chat completion stream\n     */\n    stream(body, options) {\n        return ChatCompletionStream.createChatCompletion(this._client, body, options);\n    }\n}\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as CompletionsAPI from \"./completions.mjs\";\nexport class Chat extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\n(function (Chat) {\n    Chat.Completions = CompletionsAPI.Completions;\n})(Chat || (Chat = {}));\n//# sourceMappingURL=chat.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class Sessions extends APIResource {\n    /**\n     * Create an ephemeral API token for use in client-side applications with the\n     * Realtime API. Can be configured with the same session parameters as the\n     * `session.update` client event.\n     *\n     * It responds with a session object, plus a `client_secret` key which contains a\n     * usable ephemeral API token that can be used to authenticate browser clients for\n     * the Realtime API.\n     */\n    create(body, options) {\n        return this._client.post('/realtime/sessions', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\n//# sourceMappingURL=sessions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class TranscriptionSessions extends APIResource {\n    /**\n     * Create an ephemeral API token for use in client-side applications with the\n     * Realtime API specifically for realtime transcriptions. Can be configured with\n     * the same session parameters as the `transcription_session.update` client event.\n     *\n     * It responds with a session object, plus a `client_secret` key which contains a\n     * usable ephemeral API token that can be used to authenticate browser clients for\n     * the Realtime API.\n     */\n    create(body, options) {\n        return this._client.post('/realtime/transcription_sessions', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\n//# sourceMappingURL=transcription-sessions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as SessionsAPI from \"./sessions.mjs\";\nimport { Sessions, } from \"./sessions.mjs\";\nimport * as TranscriptionSessionsAPI from \"./transcription-sessions.mjs\";\nimport { TranscriptionSessions, } from \"./transcription-sessions.mjs\";\nexport class Realtime extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.sessions = new SessionsAPI.Sessions(this._client);\n        this.transcriptionSessions = new TranscriptionSessionsAPI.TranscriptionSessions(this._client);\n    }\n}\nRealtime.Sessions = Sessions;\nRealtime.TranscriptionSessions = TranscriptionSessions;\n//# sourceMappingURL=realtime.mjs.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;\nimport * as Core from \"../core.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nexport class AssistantStream extends EventStream {\n    constructor() {\n        super(...arguments);\n        _AssistantStream_instances.add(this);\n        //Track all events in a single list for reference\n        _AssistantStream_events.set(this, []);\n        //Used to accumulate deltas\n        //We are accumulating many types so the value here is not strict\n        _AssistantStream_runStepSnapshots.set(this, {});\n        _AssistantStream_messageSnapshots.set(this, {});\n        _AssistantStream_messageSnapshot.set(this, void 0);\n        _AssistantStream_finalRun.set(this, void 0);\n        _AssistantStream_currentContentIndex.set(this, void 0);\n        _AssistantStream_currentContent.set(this, void 0);\n        _AssistantStream_currentToolCallIndex.set(this, void 0);\n        _AssistantStream_currentToolCall.set(this, void 0);\n        //For current snapshot methods\n        _AssistantStream_currentEvent.set(this, void 0);\n        _AssistantStream_currentRunSnapshot.set(this, void 0);\n        _AssistantStream_currentRunStepSnapshot.set(this, void 0);\n    }\n    [(_AssistantStream_events = new WeakMap(), _AssistantStream_runStepSnapshots = new WeakMap(), _AssistantStream_messageSnapshots = new WeakMap(), _AssistantStream_messageSnapshot = new WeakMap(), _AssistantStream_finalRun = new WeakMap(), _AssistantStream_currentContentIndex = new WeakMap(), _AssistantStream_currentContent = new WeakMap(), _AssistantStream_currentToolCallIndex = new WeakMap(), _AssistantStream_currentToolCall = new WeakMap(), _AssistantStream_currentEvent = new WeakMap(), _AssistantStream_currentRunSnapshot = new WeakMap(), _AssistantStream_currentRunStepSnapshot = new WeakMap(), _AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        //Catch all for passing along all events\n        this.on('event', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    static fromReadableStream(stream) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        this._connected();\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n    static createToolAssistantStream(threadId, runId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    async _createToolAssistantStream(run, threadId, runId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.submitToolOutputs(threadId, runId, body, {\n            ...options,\n            signal: this.controller.signal,\n        });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static createThreadAssistantStream(params, thread, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._threadAssistantStream(params, thread, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    static createAssistantStream(threadId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runAssistantStream(threadId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    currentEvent() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentEvent, \"f\");\n    }\n    currentRun() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, \"f\");\n    }\n    currentMessageSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\");\n    }\n    currentRunStepSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, \"f\");\n    }\n    async finalRunSteps() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\"));\n    }\n    async finalMessages() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\"));\n    }\n    async finalRun() {\n        await this.done();\n        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n            throw Error('Final run was not received.');\n        return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n    }\n    async _createThreadAssistantStream(thread, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    async _createAssistantStream(run, threadId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static accumulateDelta(acc, delta) {\n        for (const [key, deltaValue] of Object.entries(delta)) {\n            if (!acc.hasOwnProperty(key)) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            let accValue = acc[key];\n            if (accValue === null || accValue === undefined) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // We don't accumulate these special properties\n            if (key === 'index' || key === 'type') {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // Type-specific accumulation logic\n            if (typeof accValue === 'string' && typeof deltaValue === 'string') {\n                accValue += deltaValue;\n            }\n            else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\n                accValue += deltaValue;\n            }\n            else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\n                accValue = this.accumulateDelta(accValue, deltaValue);\n            }\n            else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n                if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {\n                    accValue.push(...deltaValue); // Use spread syntax for efficient addition\n                    continue;\n                }\n                for (const deltaEntry of deltaValue) {\n                    if (!Core.isObj(deltaEntry)) {\n                        throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\n                    }\n                    const index = deltaEntry['index'];\n                    if (index == null) {\n                        console.error(deltaEntry);\n                        throw new Error('Expected array delta entry to have an `index` property');\n                    }\n                    if (typeof index !== 'number') {\n                        throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\n                    }\n                    const accEntry = accValue[index];\n                    if (accEntry == null) {\n                        accValue.push(deltaEntry);\n                    }\n                    else {\n                        accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n                    }\n                }\n                continue;\n            }\n            else {\n                throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\n            }\n            acc[key] = accValue;\n        }\n        return acc;\n    }\n    _addRun(run) {\n        return run;\n    }\n    async _threadAssistantStream(params, thread, options) {\n        return await this._createThreadAssistantStream(thread, params, options);\n    }\n    async _runAssistantStream(threadId, runs, params, options) {\n        return await this._createAssistantStream(runs, threadId, params, options);\n    }\n    async _runToolAssistantStream(threadId, runId, runs, params, options) {\n        return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n    }\n}\n_AssistantStream_addEvent = function _AssistantStream_addEvent(event) {\n    if (this.ended)\n        return;\n    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleEvent).call(this, event);\n    switch (event.event) {\n        case 'thread.created':\n            //No action on this event.\n            break;\n        case 'thread.run.created':\n        case 'thread.run.queued':\n        case 'thread.run.in_progress':\n        case 'thread.run.requires_action':\n        case 'thread.run.completed':\n        case 'thread.run.incomplete':\n        case 'thread.run.failed':\n        case 'thread.run.cancelling':\n        case 'thread.run.cancelled':\n        case 'thread.run.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRun).call(this, event);\n            break;\n        case 'thread.run.step.created':\n        case 'thread.run.step.in_progress':\n        case 'thread.run.step.delta':\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRunStep).call(this, event);\n            break;\n        case 'thread.message.created':\n        case 'thread.message.in_progress':\n        case 'thread.message.delta':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleMessage).call(this, event);\n            break;\n        case 'error':\n            //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n            throw new Error('Encountered an error event in event processing - errors should be processed earlier');\n        default:\n            assertNever(event);\n    }\n}, _AssistantStream_endRequest = function _AssistantStream_endRequest() {\n    if (this.ended) {\n        throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n        throw Error('Final run has not been received');\n    return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {\n    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\")[accumulatedMessage.id] = accumulatedMessage;\n    for (const content of newContent) {\n        const snapshotContent = accumulatedMessage.content[content.index];\n        if (snapshotContent?.type == 'text') {\n            this._emit('textCreated', snapshotContent.text);\n        }\n    }\n    switch (event.event) {\n        case 'thread.message.created':\n            this._emit('messageCreated', event.data);\n            break;\n        case 'thread.message.in_progress':\n            break;\n        case 'thread.message.delta':\n            this._emit('messageDelta', event.data.delta, accumulatedMessage);\n            if (event.data.delta.content) {\n                for (const content of event.data.delta.content) {\n                    //If it is text delta, emit a text delta event\n                    if (content.type == 'text' && content.text) {\n                        let textDelta = content.text;\n                        let snapshot = accumulatedMessage.content[content.index];\n                        if (snapshot && snapshot.type == 'text') {\n                            this._emit('textDelta', textDelta, snapshot.text);\n                        }\n                        else {\n                            throw Error('The snapshot associated with this text delta is not text or missing');\n                        }\n                    }\n                    if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")) {\n                        //See if we have in progress content\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\")) {\n                            switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").type) {\n                                case 'text':\n                                    this._emit('textDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                                case 'image_file':\n                                    this._emit('imageFileDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                            }\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, \"f\");\n                    }\n                    __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], \"f\");\n                }\n            }\n            break;\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //We emit the latest content we were working on on completion (including incomplete)\n            if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\") !== undefined) {\n                const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")];\n                if (currentContent) {\n                    switch (currentContent.type) {\n                        case 'image_file':\n                            this._emit('imageFileDone', currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                        case 'text':\n                            this._emit('textDone', currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                    }\n                }\n            }\n            if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\")) {\n                this._emit('messageDone', event.data);\n            }\n            __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, \"f\");\n    }\n}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {\n    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateRunStep).call(this, event);\n    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, \"f\");\n    switch (event.event) {\n        case 'thread.run.step.created':\n            this._emit('runStepCreated', event.data);\n            break;\n        case 'thread.run.step.delta':\n            const delta = event.data.delta;\n            if (delta.step_details &&\n                delta.step_details.type == 'tool_calls' &&\n                delta.step_details.tool_calls &&\n                accumulatedRunStep.step_details.type == 'tool_calls') {\n                for (const toolCall of delta.step_details.tool_calls) {\n                    if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, \"f\")) {\n                        this._emit('toolCallDelta', toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);\n                    }\n                    else {\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                            this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, \"f\");\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], \"f\");\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"))\n                            this._emit('toolCallCreated', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    }\n                }\n            }\n            this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\n            break;\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, \"f\");\n            const details = event.data.step_details;\n            if (details.type == 'tool_calls') {\n                if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                    this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n                }\n            }\n            this._emit('runStepDone', event.data, accumulatedRunStep);\n            break;\n        case 'thread.run.step.in_progress':\n            break;\n    }\n}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {\n    __classPrivateFieldGet(this, _AssistantStream_events, \"f\").push(event);\n    this._emit('event', event);\n}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {\n    switch (event.event) {\n        case 'thread.run.step.created':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            return event.data;\n        case 'thread.run.step.delta':\n            let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n            if (!snapshot) {\n                throw Error('Received a RunStepDelta before creation of a snapshot');\n            }\n            let data = event.data;\n            if (data.delta) {\n                const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);\n                __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = accumulated;\n            }\n            return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n        case 'thread.run.step.in_progress':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            break;\n    }\n    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id])\n        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n    throw new Error('No snapshot available');\n}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {\n    let newContent = [];\n    switch (event.event) {\n        case 'thread.message.created':\n            //On creation the snapshot is just the initial message\n            return [event.data, newContent];\n        case 'thread.message.delta':\n            if (!snapshot) {\n                throw Error('Received a delta with no existing snapshot (there should be one from message creation)');\n            }\n            let data = event.data;\n            //If this delta does not have content, nothing to process\n            if (data.delta.content) {\n                for (const contentElement of data.delta.content) {\n                    if (contentElement.index in snapshot.content) {\n                        let currentContent = snapshot.content[contentElement.index];\n                        snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);\n                    }\n                    else {\n                        snapshot.content[contentElement.index] = contentElement;\n                        // This is a new element\n                        newContent.push(contentElement);\n                    }\n                }\n            }\n            return [snapshot, newContent];\n        case 'thread.message.in_progress':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //No changes on other thread events\n            if (snapshot) {\n                return [snapshot, newContent];\n            }\n            else {\n                throw Error('Received thread message event with no existing snapshot');\n            }\n    }\n    throw Error('Tried to accumulate a non-message event');\n}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {\n    return AssistantStream.accumulateDelta(currentContent, contentElement);\n}, _AssistantStream_handleRun = function _AssistantStream_handleRun(event) {\n    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, \"f\");\n    switch (event.event) {\n        case 'thread.run.created':\n            break;\n        case 'thread.run.queued':\n            break;\n        case 'thread.run.in_progress':\n            break;\n        case 'thread.run.requires_action':\n        case 'thread.run.cancelled':\n        case 'thread.run.failed':\n        case 'thread.run.completed':\n        case 'thread.run.expired':\n            __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, \"f\");\n            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n            }\n            break;\n        case 'thread.run.cancelling':\n            break;\n    }\n};\nfunction assertNever(_x) { }\n//# sourceMappingURL=AssistantStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Messages extends APIResource {\n    /**\n     * Create a message.\n     */\n    create(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieve a message.\n     */\n    retrieve(threadId, messageId, options) {\n        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a message.\n     */\n    update(threadId, messageId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Deletes a message.\n     */\n    del(threadId, messageId, options) {\n        return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class MessagesPage extends CursorPage {\n}\nMessages.MessagesPage = MessagesPage;\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../../core.mjs\";\nimport { CursorPage } from \"../../../../pagination.mjs\";\nexport class Steps extends APIResource {\n    retrieve(threadId, runId, stepId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.retrieve(threadId, runId, stepId, {}, query);\n        }\n        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, runId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, runId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class RunStepsPage extends CursorPage {\n}\nSteps.RunStepsPage = RunStepsPage;\n//# sourceMappingURL=steps.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../../core.mjs\";\nimport { AssistantStream } from \"../../../../lib/AssistantStream.mjs\";\nimport { sleep } from \"../../../../core.mjs\";\nimport * as StepsAPI from \"./steps.mjs\";\nimport { RunStepsPage, Steps, } from \"./steps.mjs\";\nimport { CursorPage } from \"../../../../pagination.mjs\";\nexport class Runs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.steps = new StepsAPI.Steps(this._client);\n    }\n    create(threadId, params, options) {\n        const { include, ...body } = params;\n        return this._client.post(`/threads/${threadId}/runs`, {\n            query: { include },\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: params.stream ?? false,\n        });\n    }\n    /**\n     * Retrieves a run.\n     */\n    retrieve(threadId, runId, options) {\n        return this._client.get(`/threads/${threadId}/runs/${runId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a run.\n     */\n    update(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancels a run that is `in_progress`.\n     */\n    cancel(threadId, runId, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * A helper to create a run an poll for a terminal state. More information on Run\n     * lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndPoll(threadId, body, options) {\n        const run = await this.create(threadId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Create a Run stream\n     *\n     * @deprecated use `stream` instead\n     */\n    createAndStream(threadId, body, options) {\n        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    /**\n     * A helper to poll a run status until it reaches a terminal state. More\n     * information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async poll(threadId, runId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: run, response } = await this.retrieve(threadId, runId, {\n                ...options,\n                headers: { ...options?.headers, ...headers },\n            }).withResponse();\n            switch (run.status) {\n                //If we are in any sort of intermediate state we poll\n                case 'queued':\n                case 'in_progress':\n                case 'cancelling':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                //We return the run in any terminal state.\n                case 'requires_action':\n                case 'incomplete':\n                case 'cancelled':\n                case 'completed':\n                case 'failed':\n                case 'expired':\n                    return run;\n            }\n        }\n    }\n    /**\n     * Create a Run stream\n     */\n    stream(threadId, body, options) {\n        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    submitToolOutputs(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to submit a tool output to a run and poll for a terminal run state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async submitToolOutputsAndPoll(threadId, runId, body, options) {\n        const run = await this.submitToolOutputs(threadId, runId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Submit the tool outputs from a previous run and stream the run to a terminal\n     * state. More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    submitToolOutputsStream(threadId, runId, body, options) {\n        return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);\n    }\n}\nexport class RunsPage extends CursorPage {\n}\nRuns.RunsPage = RunsPage;\nRuns.Steps = Steps;\nRuns.RunStepsPage = RunStepsPage;\n//# sourceMappingURL=runs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { AssistantStream } from \"../../../lib/AssistantStream.mjs\";\nimport * as MessagesAPI from \"./messages.mjs\";\nimport { Messages, MessagesPage, } from \"./messages.mjs\";\nimport * as RunsAPI from \"./runs/runs.mjs\";\nimport { Runs, RunsPage, } from \"./runs/runs.mjs\";\nexport class Threads extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.runs = new RunsAPI.Runs(this._client);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n    create(body = {}, options) {\n        if (isRequestOptions(body)) {\n            return this.create({}, body);\n        }\n        return this._client.post('/threads', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a thread.\n     */\n    retrieve(threadId, options) {\n        return this._client.get(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a thread.\n     */\n    update(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a thread.\n     */\n    del(threadId, options) {\n        return this._client.delete(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    createAndRun(body, options) {\n        return this._client.post('/threads/runs', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to create a thread, start a run and then poll for a terminal state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndRunPoll(body, options) {\n        const run = await this.createAndRun(body, options);\n        return await this.runs.poll(run.thread_id, run.id, options);\n    }\n    /**\n     * Create a thread and stream the run back\n     */\n    createAndRunStream(body, options) {\n        return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);\n    }\n}\nThreads.Runs = Runs;\nThreads.RunsPage = RunsPage;\nThreads.Messages = Messages;\nThreads.MessagesPage = MessagesPage;\n//# sourceMappingURL=threads.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as AssistantsAPI from \"./assistants.mjs\";\nimport * as ChatAPI from \"./chat/chat.mjs\";\nimport { Assistants, AssistantsPage, } from \"./assistants.mjs\";\nimport * as RealtimeAPI from \"./realtime/realtime.mjs\";\nimport { Realtime } from \"./realtime/realtime.mjs\";\nimport * as ThreadsAPI from \"./threads/threads.mjs\";\nimport { Threads, } from \"./threads/threads.mjs\";\nimport { Chat } from \"./chat/chat.mjs\";\nexport class Beta extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.realtime = new RealtimeAPI.Realtime(this._client);\n        this.chat = new ChatAPI.Chat(this._client);\n        this.assistants = new AssistantsAPI.Assistants(this._client);\n        this.threads = new ThreadsAPI.Threads(this._client);\n    }\n}\nBeta.Realtime = Realtime;\nBeta.Assistants = Assistants;\nBeta.AssistantsPage = AssistantsPage;\nBeta.Threads = Threads;\n//# sourceMappingURL=beta.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { isRequestOptions } from \"../core.mjs\";\nimport { CursorPage } from \"../pagination.mjs\";\nexport class Batches extends APIResource {\n    /**\n     * Creates and executes a batch from an uploaded file of requests\n     */\n    create(body, options) {\n        return this._client.post('/batches', { body, ...options });\n    }\n    /**\n     * Retrieves a batch.\n     */\n    retrieve(batchId, options) {\n        return this._client.get(`/batches/${batchId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/batches', BatchesPage, { query, ...options });\n    }\n    /**\n     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to\n     * 10 minutes, before changing to `cancelled`, where it will have partial results\n     * (if any) available in the output file.\n     */\n    cancel(batchId, options) {\n        return this._client.post(`/batches/${batchId}/cancel`, options);\n    }\n}\nexport class BatchesPage extends CursorPage {\n}\nBatches.BatchesPage = BatchesPage;\n//# sourceMappingURL=batches.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Parts extends APIResource {\n    /**\n     * Adds a\n     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.\n     * A Part represents a chunk of bytes from the file you are trying to upload.\n     *\n     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload\n     * maximum of 8 GB.\n     *\n     * It is possible to add multiple Parts in parallel. You can decide the intended\n     * order of the Parts when you\n     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).\n     */\n    create(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/parts`, Core.multipartFormRequestOptions({ body, ...options }));\n    }\n}\n//# sourceMappingURL=parts.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as PartsAPI from \"./parts.mjs\";\nimport { Parts } from \"./parts.mjs\";\nexport class Uploads extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.parts = new PartsAPI.Parts(this._client);\n    }\n    /**\n     * Creates an intermediate\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object\n     * that you can add\n     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.\n     * Currently, an Upload can accept at most 8 GB in total and expires after an hour\n     * after you create it.\n     *\n     * Once you complete the Upload, we will create a\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * contains all the parts you uploaded. This File is usable in the rest of our\n     * platform as a regular File object.\n     *\n     * For certain `purpose` values, the correct `mime_type` must be specified. Please\n     * refer to documentation for the\n     * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).\n     *\n     * For guidance on the proper filename extensions for each purpose, please follow\n     * the documentation on\n     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).\n     */\n    create(body, options) {\n        return this._client.post('/uploads', { body, ...options });\n    }\n    /**\n     * Cancels the Upload. No Parts may be added after an Upload is cancelled.\n     */\n    cancel(uploadId, options) {\n        return this._client.post(`/uploads/${uploadId}/cancel`, options);\n    }\n    /**\n     * Completes the\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).\n     *\n     * Within the returned Upload object, there is a nested\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * is ready to use in the rest of the platform.\n     *\n     * You can specify the order of the Parts by passing in an ordered list of the Part\n     * IDs.\n     *\n     * The number of bytes uploaded upon completion must match the number of bytes\n     * initially specified when creating the Upload object. No Parts may be added after\n     * an Upload is completed.\n     */\n    complete(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });\n    }\n}\nUploads.Parts = Parts;\n//# sourceMappingURL=uploads.mjs.map","import { OpenAIError } from \"../error.mjs\";\nimport { isAutoParsableResponseFormat } from \"../lib/parser.mjs\";\nexport function maybeParseResponse(response, params) {\n    if (!params || !hasAutoParseableInput(params)) {\n        return {\n            ...response,\n            output_parsed: null,\n            output: response.output.map((item) => {\n                if (item.type === 'function_call') {\n                    return {\n                        ...item,\n                        parsed_arguments: null,\n                    };\n                }\n                if (item.type === 'message') {\n                    return {\n                        ...item,\n                        content: item.content.map((content) => ({\n                            ...content,\n                            parsed: null,\n                        })),\n                    };\n                }\n                else {\n                    return item;\n                }\n            }),\n        };\n    }\n    return parseResponse(response, params);\n}\nexport function parseResponse(response, params) {\n    const output = response.output.map((item) => {\n        if (item.type === 'function_call') {\n            return {\n                ...item,\n                parsed_arguments: parseToolCall(params, item),\n            };\n        }\n        if (item.type === 'message') {\n            const content = item.content.map((content) => {\n                if (content.type === 'output_text') {\n                    return {\n                        ...content,\n                        parsed: parseTextFormat(params, content.text),\n                    };\n                }\n                return content;\n            });\n            return {\n                ...item,\n                content,\n            };\n        }\n        return item;\n    });\n    const parsed = Object.assign({}, response, { output });\n    if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n        addOutputText(parsed);\n    }\n    Object.defineProperty(parsed, 'output_parsed', {\n        enumerable: true,\n        get() {\n            for (const output of parsed.output) {\n                if (output.type !== 'message') {\n                    continue;\n                }\n                for (const content of output.content) {\n                    if (content.type === 'output_text' && content.parsed !== null) {\n                        return content.parsed;\n                    }\n                }\n            }\n            return null;\n        },\n    });\n    return parsed;\n}\nfunction parseTextFormat(params, content) {\n    if (params.text?.format?.type !== 'json_schema') {\n        return null;\n    }\n    if ('$parseRaw' in params.text?.format) {\n        const text_format = params.text?.format;\n        return text_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n}\nexport function hasAutoParseableInput(params) {\n    if (isAutoParsableResponseFormat(params.text?.format)) {\n        return true;\n    }\n    return false;\n}\nexport function makeParseableResponseTool(tool, { parser, callback, }) {\n    const obj = { ...tool };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-tool',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n        $callback: {\n            value: callback,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableTool(tool) {\n    return tool?.['$brand'] === 'auto-parseable-tool';\n}\nfunction getInputToolByName(input_tools, name) {\n    return input_tools.find((tool) => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n    return {\n        ...toolCall,\n        ...toolCall,\n        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments)\n            : inputTool?.strict ? JSON.parse(toolCall.arguments)\n                : null,\n    };\n}\nexport function shouldParseToolCall(params, toolCall) {\n    if (!params) {\n        return false;\n    }\n    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n    return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\nexport function validateInputTools(tools) {\n    for (const tool of tools ?? []) {\n        if (tool.type !== 'function') {\n            throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        }\n        if (tool.function.strict !== true) {\n            throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n        }\n    }\n}\nexport function addOutputText(rsp) {\n    const texts = [];\n    for (const output of rsp.output) {\n        if (output.type !== 'message') {\n            continue;\n        }\n        for (const content of output.content) {\n            if (content.type === 'output_text') {\n                texts.push(content.text);\n            }\n        }\n    }\n    rsp.output_text = texts.join('');\n}\n//# sourceMappingURL=ResponsesParser.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { ResponseItemsPage } from \"./responses.mjs\";\nexport class InputItems extends APIResource {\n    list(responseId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(responseId, {}, query);\n        }\n        return this._client.getAPIList(`/responses/${responseId}/input_items`, ResponseItemsPage, {\n            query,\n            ...options,\n        });\n    }\n}\nexport { ResponseItemsPage };\n//# sourceMappingURL=input-items.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;\nimport { APIUserAbortError, OpenAIError } from \"../../error.mjs\";\nimport { EventStream } from \"../EventStream.mjs\";\nimport { maybeParseResponse } from \"../ResponsesParser.mjs\";\nexport class ResponseStream extends EventStream {\n    constructor(params) {\n        super();\n        _ResponseStream_instances.add(this);\n        _ResponseStream_params.set(this, void 0);\n        _ResponseStream_currentResponseSnapshot.set(this, void 0);\n        _ResponseStream_finalResponse.set(this, void 0);\n        __classPrivateFieldSet(this, _ResponseStream_params, params, \"f\");\n    }\n    static createResponse(client, params, options) {\n        const runner = new ResponseStream(params);\n        runner._run(() => runner._createResponse(client, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    async _createResponse(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_beginRequest).call(this);\n        const stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_endRequest).call(this);\n    }\n    [(_ResponseStream_params = new WeakMap(), _ResponseStream_currentResponseSnapshot = new WeakMap(), _ResponseStream_finalResponse = new WeakMap(), _ResponseStream_instances = new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n    }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event) {\n        if (this.ended)\n            return;\n        const response = __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_accumulateResponse).call(this, event);\n        this._emit('event', event);\n        switch (event.type) {\n            case 'response.output_text.delta': {\n                const output = response.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    const content = output.content[event.content_index];\n                    if (!content) {\n                        throw new OpenAIError(`missing content at index ${event.content_index}`);\n                    }\n                    if (content.type !== 'output_text') {\n                        throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n                    }\n                    this._emit('response.output_text.delta', {\n                        ...event,\n                        snapshot: content.text,\n                    });\n                }\n                break;\n            }\n            case 'response.function_call_arguments.delta': {\n                const output = response.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'function_call') {\n                    this._emit('response.function_call_arguments.delta', {\n                        ...event,\n                        snapshot: output.arguments,\n                    });\n                }\n                break;\n            }\n            default:\n                // @ts-ignore\n                this._emit(event.type, event);\n                break;\n        }\n    }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {\n        if (this.ended) {\n            throw new OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n        if (!snapshot) {\n            throw new OpenAIError(`request ended without sending any events`);\n        }\n        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n        const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, \"f\"));\n        __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, \"f\");\n        return parsedResponse;\n    }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {\n        let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n        if (!snapshot) {\n            if (event.type !== 'response.created') {\n                throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);\n            }\n            snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n            return snapshot;\n        }\n        switch (event.type) {\n            case 'response.output_item.added': {\n                snapshot.output.push(event.item);\n                break;\n            }\n            case 'response.content_part.added': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    output.content.push(event.part);\n                }\n                break;\n            }\n            case 'response.output_text.delta': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    const content = output.content[event.content_index];\n                    if (!content) {\n                        throw new OpenAIError(`missing content at index ${event.content_index}`);\n                    }\n                    if (content.type !== 'output_text') {\n                        throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n                    }\n                    content.text += event.delta;\n                }\n                break;\n            }\n            case 'response.function_call_arguments.delta': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'function_call') {\n                    output.arguments += event.delta;\n                }\n                break;\n            }\n            case 'response.completed': {\n                __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n                break;\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('event', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event) => (event ? { value: event, done: false } : { value: undefined, done: true }));\n                }\n                const event = pushQueue.shift();\n                return { value: event, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    /**\n     * @returns a promise that resolves with the final Response, or rejects\n     * if an error occurred or the stream ended prematurely without producing a REsponse.\n     */\n    async finalResponse() {\n        await this.done();\n        const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, \"f\");\n        if (!response)\n            throw new OpenAIError('stream ended without producing a ChatCompletion');\n        return response;\n    }\n}\nfunction finalizeResponse(snapshot, params) {\n    return maybeParseResponse(snapshot, params);\n}\n//# sourceMappingURL=ResponseStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { parseResponse, addOutputText, } from \"../../lib/ResponsesParser.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { APIResource } from \"../../resource.mjs\";\nimport * as InputItemsAPI from \"./input-items.mjs\";\nimport { InputItems } from \"./input-items.mjs\";\nimport { ResponseStream } from \"../../lib/responses/ResponseStream.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Responses extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.inputItems = new InputItemsAPI.InputItems(this._client);\n    }\n    create(body, options) {\n        return this._client.post('/responses', { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {\n            if ('object' in rsp && rsp.object === 'response') {\n                addOutputText(rsp);\n            }\n            return rsp;\n        });\n    }\n    retrieve(responseId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.retrieve(responseId, {}, query);\n        }\n        return this._client.get(`/responses/${responseId}`, { query, ...options });\n    }\n    /**\n     * Deletes a model response with the given ID.\n     */\n    del(responseId, options) {\n        return this._client.delete(`/responses/${responseId}`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n    parse(body, options) {\n        return this._client.responses\n            .create(body, options)\n            ._thenUnwrap((response) => parseResponse(response, body));\n    }\n    /**\n     * Creates a chat completion stream\n     */\n    stream(body, options) {\n        return ResponseStream.createResponse(this._client, body, options);\n    }\n}\nexport class ResponseItemsPage extends CursorPage {\n}\nResponses.InputItems = InputItems;\n//# sourceMappingURL=responses.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _a;\nimport * as qs from \"./internal/qs/index.mjs\";\nimport * as Core from \"./core.mjs\";\nimport * as Errors from \"./error.mjs\";\nimport * as Pagination from \"./pagination.mjs\";\nimport * as Uploads from \"./uploads.mjs\";\nimport * as API from \"./resources/index.mjs\";\nimport { Batches, BatchesPage, } from \"./resources/batches.mjs\";\nimport { Completions, } from \"./resources/completions.mjs\";\nimport { Embeddings, } from \"./resources/embeddings.mjs\";\nimport { FileObjectsPage, Files, } from \"./resources/files.mjs\";\nimport { Images, } from \"./resources/images.mjs\";\nimport { Models, ModelsPage } from \"./resources/models.mjs\";\nimport { Moderations, } from \"./resources/moderations.mjs\";\nimport { Audio } from \"./resources/audio/audio.mjs\";\nimport { Beta } from \"./resources/beta/beta.mjs\";\nimport { Chat } from \"./resources/chat/chat.mjs\";\nimport { FineTuning } from \"./resources/fine-tuning/fine-tuning.mjs\";\nimport { Responses } from \"./resources/responses/responses.mjs\";\nimport { Uploads as UploadsAPIUploads, } from \"./resources/uploads/uploads.mjs\";\nimport { VectorStoreSearchResponsesPage, VectorStores, VectorStoresPage, } from \"./resources/vector-stores/vector-stores.mjs\";\nimport { ChatCompletionsPage, } from \"./resources/chat/completions/completions.mjs\";\n/**\n * API Client for interfacing with the OpenAI API.\n */\nexport class OpenAI extends Core.APIClient {\n    /**\n     * API Client for interfacing with the OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('OPENAI_API_KEY'), organization = Core.readEnv('OPENAI_ORG_ID') ?? null, project = Core.readEnv('OPENAI_PROJECT_ID') ?? null, ...opts } = {}) {\n        if (apiKey === undefined) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\");\n        }\n        const options = {\n            apiKey,\n            organization,\n            project,\n            ...opts,\n            baseURL: baseURL || `https://api.openai.com/v1`,\n        };\n        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n            throw new Errors.OpenAIError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\\n\\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\\n\");\n        }\n        super({\n            baseURL: options.baseURL,\n            timeout: options.timeout ?? 600000 /* 10 minutes */,\n            httpAgent: options.httpAgent,\n            maxRetries: options.maxRetries,\n            fetch: options.fetch,\n        });\n        this.completions = new API.Completions(this);\n        this.chat = new API.Chat(this);\n        this.embeddings = new API.Embeddings(this);\n        this.files = new API.Files(this);\n        this.images = new API.Images(this);\n        this.audio = new API.Audio(this);\n        this.moderations = new API.Moderations(this);\n        this.models = new API.Models(this);\n        this.fineTuning = new API.FineTuning(this);\n        this.vectorStores = new API.VectorStores(this);\n        this.beta = new API.Beta(this);\n        this.batches = new API.Batches(this);\n        this.uploads = new API.Uploads(this);\n        this.responses = new API.Responses(this);\n        this._options = options;\n        this.apiKey = apiKey;\n        this.organization = organization;\n        this.project = project;\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    defaultHeaders(opts) {\n        return {\n            ...super.defaultHeaders(opts),\n            'OpenAI-Organization': this.organization,\n            'OpenAI-Project': this.project,\n            ...this._options.defaultHeaders,\n        };\n    }\n    authHeaders(opts) {\n        return { Authorization: `Bearer ${this.apiKey}` };\n    }\n    stringifyQuery(query) {\n        return qs.stringify(query, { arrayFormat: 'brackets' });\n    }\n}\n_a = OpenAI;\nOpenAI.OpenAI = _a;\nOpenAI.DEFAULT_TIMEOUT = 600000; // 10 minutes\nOpenAI.OpenAIError = Errors.OpenAIError;\nOpenAI.APIError = Errors.APIError;\nOpenAI.APIConnectionError = Errors.APIConnectionError;\nOpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\nOpenAI.APIUserAbortError = Errors.APIUserAbortError;\nOpenAI.NotFoundError = Errors.NotFoundError;\nOpenAI.ConflictError = Errors.ConflictError;\nOpenAI.RateLimitError = Errors.RateLimitError;\nOpenAI.BadRequestError = Errors.BadRequestError;\nOpenAI.AuthenticationError = Errors.AuthenticationError;\nOpenAI.InternalServerError = Errors.InternalServerError;\nOpenAI.PermissionDeniedError = Errors.PermissionDeniedError;\nOpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;\nOpenAI.toFile = Uploads.toFile;\nOpenAI.fileFromPath = Uploads.fileFromPath;\nOpenAI.Completions = Completions;\nOpenAI.Chat = Chat;\nOpenAI.ChatCompletionsPage = ChatCompletionsPage;\nOpenAI.Embeddings = Embeddings;\nOpenAI.Files = Files;\nOpenAI.FileObjectsPage = FileObjectsPage;\nOpenAI.Images = Images;\nOpenAI.Audio = Audio;\nOpenAI.Moderations = Moderations;\nOpenAI.Models = Models;\nOpenAI.ModelsPage = ModelsPage;\nOpenAI.FineTuning = FineTuning;\nOpenAI.VectorStores = VectorStores;\nOpenAI.VectorStoresPage = VectorStoresPage;\nOpenAI.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;\nOpenAI.Beta = Beta;\nOpenAI.Batches = Batches;\nOpenAI.BatchesPage = BatchesPage;\nOpenAI.Uploads = UploadsAPIUploads;\nOpenAI.Responses = Responses;\n/** API Client for interfacing with the Azure OpenAI API. */\nexport class AzureOpenAI extends OpenAI {\n    /**\n     * API Client for interfacing with the Azure OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]\n     * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`\n     * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]\n     * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('AZURE_OPENAI_API_KEY'), apiVersion = Core.readEnv('OPENAI_API_VERSION'), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}) {\n        if (!apiVersion) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).\");\n        }\n        if (typeof azureADTokenProvider === 'function') {\n            dangerouslyAllowBrowser = true;\n        }\n        if (!azureADTokenProvider && !apiKey) {\n            throw new Errors.OpenAIError('Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.');\n        }\n        if (azureADTokenProvider && apiKey) {\n            throw new Errors.OpenAIError('The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.');\n        }\n        // define a sentinel value to avoid any typing issues\n        apiKey ?? (apiKey = API_KEY_SENTINEL);\n        opts.defaultQuery = { ...opts.defaultQuery, 'api-version': apiVersion };\n        if (!baseURL) {\n            if (!endpoint) {\n                endpoint = process.env['AZURE_OPENAI_ENDPOINT'];\n            }\n            if (!endpoint) {\n                throw new Errors.OpenAIError('Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable');\n            }\n            baseURL = `${endpoint}/openai`;\n        }\n        else {\n            if (endpoint) {\n                throw new Errors.OpenAIError('baseURL and endpoint are mutually exclusive');\n            }\n        }\n        super({\n            apiKey,\n            baseURL,\n            ...opts,\n            ...(dangerouslyAllowBrowser !== undefined ? { dangerouslyAllowBrowser } : {}),\n        });\n        this.apiVersion = '';\n        this._azureADTokenProvider = azureADTokenProvider;\n        this.apiVersion = apiVersion;\n        this.deploymentName = deployment;\n    }\n    buildRequest(options, props = {}) {\n        if (_deployments_endpoints.has(options.path) && options.method === 'post' && options.body !== undefined) {\n            if (!Core.isObj(options.body)) {\n                throw new Error('Expected request body to be an object');\n            }\n            const model = this.deploymentName || options.body['model'] || options.__metadata?.['model'];\n            if (model !== undefined && !this.baseURL.includes('/deployments')) {\n                options.path = `/deployments/${model}${options.path}`;\n            }\n        }\n        return super.buildRequest(options, props);\n    }\n    async _getAzureADToken() {\n        if (typeof this._azureADTokenProvider === 'function') {\n            const token = await this._azureADTokenProvider();\n            if (!token || typeof token !== 'string') {\n                throw new Errors.OpenAIError(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);\n            }\n            return token;\n        }\n        return undefined;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    async prepareOptions(opts) {\n        /**\n         * The user should provide a bearer token provider if they want\n         * to use Azure AD authentication. The user shouldn't set the\n         * Authorization header manually because the header is overwritten\n         * with the Azure AD token if a bearer token provider is provided.\n         */\n        if (opts.headers?.['api-key']) {\n            return super.prepareOptions(opts);\n        }\n        const token = await this._getAzureADToken();\n        opts.headers ?? (opts.headers = {});\n        if (token) {\n            opts.headers['Authorization'] = `Bearer ${token}`;\n        }\n        else if (this.apiKey !== API_KEY_SENTINEL) {\n            opts.headers['api-key'] = this.apiKey;\n        }\n        else {\n            throw new Errors.OpenAIError('Unable to handle auth');\n        }\n        return super.prepareOptions(opts);\n    }\n}\nconst _deployments_endpoints = new Set([\n    '/completions',\n    '/chat/completions',\n    '/embeddings',\n    '/audio/transcriptions',\n    '/audio/translations',\n    '/audio/speech',\n    '/images/generations',\n]);\nconst API_KEY_SENTINEL = '<Missing Key>';\nexport { toFile, fileFromPath } from \"./uploads.mjs\";\nexport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, NotFoundError, ConflictError, RateLimitError, BadRequestError, AuthenticationError, InternalServerError, PermissionDeniedError, UnprocessableEntityError, } from \"./error.mjs\";\nexport default OpenAI;\n//# sourceMappingURL=index.mjs.map"],"names":["_platformHeaders","kind","registry_fetch","registry_FormData","registry_File","registry_ReadableStream","registry_getMultipartRequestOptions","getDefaultAgent","fileFromPath","isFsReadStream","default_format","formatters","RFC1738","String","v","replace","RFC3986","is_array","Object","prototype","hasOwnProperty","Array","isArray","hex_table","array","i","push","toString","toUpperCase","maybe_map","val","fn","mapped","length","stringify_has","array_prefix_generators","brackets","prefix","comma","indices","key","repeat","stringify_is_array","push_to_array","arr","value_or_array","apply","to_ISO","Date","toISOString","defaults","addQueryPrefix","allowDots","allowEmptyArrays","arrayFormat","charset","charsetSentinel","delimiter","encode","encodeDotInKeys","encoder","str","_defaultEncoder","_kind","format","string","Symbol","call","escape","$0","parseInt","slice","out","j","segment","c","charCodeAt","charAt","join","encodeValuesOnly","formatter","serializeDate","date","skipNulls","strictNullHandling","sentinel","VERSION","auto","MultipartBody","constructor","body","toStringTag","setShims","shims","options","fetch","Request","Response","Headers","FormData","Blob","File","ReadableStream","getMultipartRequestOptions","getRuntime","manuallyImported","_fetch","_Request","_Response","_Headers","recommendation","error","message","form","opts","undefined","error_OpenAIError","Error","APIError","status","headers","makeMessage","request_id","code","param","type","msg","JSON","stringify","generate","errorResponse","APIConnectionError","cause","castToError","BadRequestError","AuthenticationError","PermissionDeniedError","NotFoundError","ConflictError","UnprocessableEntityError","RateLimitError","InternalServerError","APIUserAbortError","APIConnectionTimeoutError","LengthFinishReasonError","ContentFilterFinishReasonError","_LineDecoder_carriageReturnIndex","_AbstractPage_client","_EventStream_instances","_EventStream_connectedPromise","_EventStream_resolveConnectedPromise","_EventStream_rejectConnectedPromise","_EventStream_endPromise","_EventStream_resolveEndPromise","_EventStream_rejectEndPromise","_EventStream_listeners","_EventStream_ended","_EventStream_errored","_EventStream_aborted","_EventStream_catchingPromiseCreated","_EventStream_handleError","_AbstractChatCompletionRunner_instances","_AbstractChatCompletionRunner_getFinalContent","_AbstractChatCompletionRunner_getFinalMessage","_AbstractChatCompletionRunner_getFinalFunctionCall","_AbstractChatCompletionRunner_getFinalFunctionCallResult","_AbstractChatCompletionRunner_calculateTotalUsage","_AbstractChatCompletionRunner_validateParams","_AbstractChatCompletionRunner_stringifyFunctionCallResult","_ChatCompletionStream_instances","_ChatCompletionStream_params","_ChatCompletionStream_choiceEventStates","_ChatCompletionStream_currentChatCompletionSnapshot","_ChatCompletionStream_beginRequest","_ChatCompletionStream_getChoiceEventState","_ChatCompletionStream_addChunk","_ChatCompletionStream_emitToolCallDoneEvent","_ChatCompletionStream_emitContentDoneEvents","_ChatCompletionStream_endRequest","_ChatCompletionStream_getAutoParseableResponseFormat","_ChatCompletionStream_accumulateChatCompletion","_AssistantStream_instances","_AssistantStream_events","_AssistantStream_runStepSnapshots","_AssistantStream_messageSnapshots","_AssistantStream_messageSnapshot","_AssistantStream_finalRun","_AssistantStream_currentContentIndex","_AssistantStream_currentContent","_AssistantStream_currentToolCallIndex","_AssistantStream_currentToolCall","_AssistantStream_currentEvent","_AssistantStream_currentRunSnapshot","_AssistantStream_currentRunStepSnapshot","_AssistantStream_addEvent","_AssistantStream_endRequest","_AssistantStream_handleMessage","_AssistantStream_handleRunStep","_AssistantStream_handleEvent","_AssistantStream_accumulateRunStep","_AssistantStream_accumulateMessage","_AssistantStream_accumulateContent","_AssistantStream_handleRun","_ResponseStream_instances","_ResponseStream_params","_ResponseStream_currentResponseSnapshot","_ResponseStream_finalResponse","_ResponseStream_beginRequest","_ResponseStream_addEvent","_ResponseStream_endRequest","_ResponseStream_accumulateResponse","__classPrivateFieldSet","receiver","state","value","f","has","set","__classPrivateFieldGet","get","LineDecoder","buffer","Uint8Array","decode","chunk","patternIndex","binaryChunk","ArrayBuffer","TextEncoder","newData","lines","findNewlineIndex","startIndex","preceding","index","carriage","decodeText","endIndex","line","bytes","Buffer","from","name","TextDecoder","textDecoder","flush","ReadableStreamToAsyncIterable","stream","asyncIterator","reader","getReader","next","result","read","done","releaseLock","e","return","cancelPromise","cancel","WeakMap","NEWLINE_CHARS","Set","NEWLINE_REGEXP","Stream","iterator","controller","fromSSEResponse","response","consumed","sse","_iterSSEMessages","data","startsWith","event","parse","console","raw","abort","fromReadableStream","readableStream","iterLines","lineDecoder","tee","left","right","teeIterator","queue","shift","toReadableStream","iter","self","start","pull","ctrl","close","enqueue","err","sseDecoder","SSEDecoder","sseChunk","iterSSEChunks","findDoubleNewlineIndex","chunks","endsWith","substring","fieldname","_","partition","indexOf","isResponseLike","url","blob","isFileLike","lastModified","isBlobLike","size","text","arrayBuffer","isUploadable","toFile","URL","pathname","split","pop","bits","getBytes","getName","getStringFromMaybeBuffer","filename","path","parts","isView","isAsyncIterableIterator","propsForError","props","getOwnPropertyNames","map","p","x","uploads_Buffer","isMultipartBody","multipartFormRequestOptions","createForm","Promise","all","entries","addFormValue","hasUploadableValue","some","k","append","file","entry","prop","core_classPrivateFieldSet","core_classPrivateFieldGet","defaultParseResponse","debug","__streamClass","__binaryResponse","contentType","mediaType","trim","includes","json","_addRequestID","defineProperty","enumerable","APIPromise","responsePromise","parseResponse","resolve","_thenUnwrap","transform","asResponse","then","withResponse","parsedPromise","onfulfilled","onrejected","catch","finally","onfinally","APIClient","baseURL","maxRetries","timeout","httpAgent","overriddenFetch","validatePositiveInteger","authHeaders","defaultHeaders","Accept","getUserAgent","getPlatformHeaders","validateHeaders","customHeaders","defaultIdempotencyKey","uuid4","methodRequest","post","patch","put","delete","method","request","DataView","getAPIList","Page","requestAPIList","calculateContentLength","core_Buffer","byteLength","encoded","buildRequest","retryCount","query","__binaryRequest","contentLength","buildURL","minAgentTimeout","idempotencyHeader","idempotencyKey","reqHeaders","buildHeaders","req","agent","signal","applyHeadersMut","getHeader","prepareOptions","prepareRequest","parseHeaders","fromEntries","header","makeStatusError","remainingRetries","makeRequest","optionsInput","retriesRemaining","aborted","AbortController","fetchWithTimeout","retryRequest","responseHeaders","createResponseHeaders","ok","shouldRetry","retryMessage","errText","errJSON","safeJSON","errMessage","PagePromise","isAbsoluteURL","defaultQuery","isEmptyObj","search","stringifyQuery","filter","encodeURIComponent","init","ms","addEventListener","setTimeout","fetchOptions","clearTimeout","shouldRetryHeader","timeoutMillis","retryAfterMillisHeader","timeoutMs","parseFloat","Number","isNaN","retryAfterHeader","timeoutSeconds","now","calculateDefaultRetryTimeoutMillis","sleep","sleepSeconds","min","initialRetryDelay","Math","pow","random","AbstractPage","client","hasNextPage","items","getPaginatedItems","nextPageInfo","getNextPage","nextInfo","nextOptions","params","searchParams","iterPages","page","item","Proxy","target","toLowerCase","requestOptionsKeys","__metadata","isRequestOptions","obj","keys","every","hasOwn","getPlatformProperties","Deno","build","normalizePlatform","os","normalizeArch","arch","version","deno","process","platform","startsWithSchemeRegexp","test","n","isInteger","readEnv","env","_k","targetHeaders","newHeaders","lowerKey","SENSITIVE_HEADERS","action","args","log","arg","modifiedArg","r","isRunningInBrowser","window","document","navigator","isHeadersProtocol","lowerCasedHeader","intercapsHeader","_m","g1","g2","warn","isObj","APIResource","_client","Completions","create","Messages","list","completionId","ChatCompletionStoreMessagesPage","object","nextPageParams","CursorPage","has_more","info","id","after","completions_Completions","arguments","messages","retrieve","update","ChatCompletionsPage","del","Chat","completions","Embeddings","Files","fileId","FileObjectsPage","content","retrieveContent","waitForProcessing","pollInterval","maxWait","TERMINAL_STATES","Images","createVariation","edit","Speech","Transcriptions","model","Translations","Audio","transcriptions","translations","speech","Moderations","Models","ModelsPage","Checkpoints","fineTuningJobId","FineTuningJobCheckpointsPage","Jobs","checkpoints","FineTuningJobsPage","listEvents","FineTuningJobEventsPage","FineTuning","jobs","allSettledWithThrow","promises","results","allSettled","rejected","reason","values","files_Files","vectorStoreId","VectorStoreFilesPage","createAndPoll","poll","pollIntervalMs","fileResponse","sleepInterval","headerInterval","headerIntervalMs","upload","fileInfo","files","purpose","file_id","uploadAndPoll","FileContentResponsesPage","FileBatches","batchId","batch","listFiles","fileIds","concurrencyLimit","maxConcurrency","fileIterator","allFileIds","processFiles","fileObj","workers","fill","file_ids","VectorStores","fileBatches","VectorStoresPage","VectorStoreSearchResponsesPage","Assistants","assistantId","AssistantsPage","isRunnableFunctionWithParse","isAssistantMessage","role","isFunctionMessage","isToolMessage","EventStream_classPrivateFieldSet","EventStream_classPrivateFieldGet","EventStream","add","reject","_run","executor","_emitFinal","_emit","bind","_connected","ended","errored","on","listener","listeners","off","findIndex","l","splice","once","emitted","forEach","isAutoParsableResponseFormat","response_format","isAutoParsableTool","tool","parseChatCompletion","completion","choices","choice","finish_reason","tool_calls","parseToolCall","toolCall","inputTool","tools","find","function","parsed_arguments","$parseRaw","strict","parsed","refusal","hasAutoParseableInput","t","WeakSet","openAIError","AbstractChatCompletionRunner_classPrivateFieldGet","AbstractChatCompletionRunner","_chatCompletions","_addChatCompletion","chatCompletion","_addMessage","emit","function_call","tool_call","finalChatCompletion","finalContent","finalMessage","finalFunctionCall","finalFunctionCallResult","totalUsage","allChatCompletions","usage","_createChatCompletion","chat","_runChatCompletion","_runFunctions","restParams","singleFunctionToCall","maxChatCompletions","functionsByName","functions","parameters","description","rawContent","_runTools","tool_choice","inputTools","$callback","tool_call_id","rest","ret","at","y","total","completion_tokens","prompt_tokens","total_tokens","ChatCompletionRunner","runFunctions","runner","runTools","Allow","STR","NUM","ARR","OBJ","NULL","BOOL","NAN","INFINITY","MINUS_INFINITY","ALL","ATOM","PartialJSON","MalformedJSON","_parseJSON","jsonString","allow","markPartialJSON","throwMalformedError","parseAny","skipBlank","parseStr","parseObj","parseArr","Infinity","NaN","parseNum","lastIndexOf","writable","configurable","partialParse","parseJSON","allowPartial","input","ChatCompletionStream_classPrivateFieldSet","ChatCompletionStream_classPrivateFieldGet","ChatCompletionStream","currentChatCompletionSnapshot","_fromReadableStream","createChatCompletion","chatId","content_done","refusal_done","logprobs_content_done","logprobs_refusal_done","done_tool_calls","current_tool_call_index","choiceSnapshot","delta","snapshot","logprobs","toolCallDelta","toolCallSnapshot","arguments_delta","toolCallIndex","responseFormat","finalizeChatCompletion","created","system_fingerprint","choiceRest","messageRest","toolRest","fnRest","_a","_b","_c","_d","other","assign","shouldParseToolCall","pushQueue","readQueue","ChatCompletionStreamingRunner","chat_completions_Completions","validateInputTools","chat_Chat","Sessions","TranscriptionSessions","Realtime","sessions","transcriptionSessions","AssistantStream_classPrivateFieldGet","AssistantStream_classPrivateFieldSet","AssistantStream","_addRun","createToolAssistantStream","threadId","runId","runs","_runToolAssistantStream","_createToolAssistantStream","run","submitToolOutputs","createThreadAssistantStream","thread","_threadAssistantStream","createAssistantStream","_runAssistantStream","currentEvent","currentRun","currentMessageSnapshot","currentRunStepSnapshot","finalRunSteps","finalMessages","finalRun","_createThreadAssistantStream","createAndRun","_createAssistantStream","accumulateDelta","acc","deltaValue","accValue","deltaEntry","accEntry","accumulatedMessage","newContent","snapshotContent","textDelta","image_file","currentContent","accumulatedRunStep","step_details","details","accumulated","contentElement","messages_Messages","messageId","MessagesPage","Steps","stepId","RunStepsPage","Runs","steps","include","RunsPage","createAndStream","beta","threads","submitToolOutputsAndPoll","submitToolOutputsStream","Threads","createAndRunPoll","thread_id","createAndRunStream","Beta","realtime","assistants","Batches","BatchesPage","Parts","uploadId","Uploads","complete","output","ResponsesParser_parseToolCall","input_tools","ResponsesParser_isAutoParsableTool","text_format","getOwnPropertyDescriptor","addOutputText","rsp","texts","output_text","InputItems","responseId","ResponseItemsPage","ResponseStream_classPrivateFieldSet","ResponseStream_classPrivateFieldGet","ResponseStream","createResponse","_createResponse","responses","output_index","content_index","parsedResponse","finalizeResponse","output_parsed","part","finalResponse","Responses","inputItems","OpenAI","apiKey","organization","project","dangerouslyAllowBrowser","embeddings","images","audio","moderations","models","fineTuning","vectorStores","batches","uploads","_options","Authorization","obj_keys","normalize_stringify_options","commaRoundTrip","sort","generateArrayPrefix","sideChannel","inner_stringify","tmp_sc","step","find_flag","pos","is_non_nullish_primitive","isBuffer","key_value","encoded_prefix","adjusted_prefix","encoded_key","key_prefix","valueSideChannel","joined","DEFAULT_TIMEOUT","OpenAIError","openai"],"sourceRoot":""}